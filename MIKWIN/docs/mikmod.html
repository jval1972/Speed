<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from mikmod.texi on 14 Febuary 1999 -->

<TITLE>MikMod sound library</TITLE>
</HEAD>
<BODY>
<H1>MikMod sound library</H1>
<H2>Documentation edition 1.0.5</H2>
<H2>February 1999</H2>
<ADDRESS>Miodrag Vallat</ADDRESS>
<ADDRESS>(<CODE><A HREF="mailto:miodrag@multimania.com">miodrag@multimania.com</A></CODE>)</ADDRESS>
<P>
<P><HR><P>

<P>

</P>
<P>
Copyright (C) 1998, 1999 Miodrag Vallat and others -- see file
AUTHORS for complete list.

</P>
<P>
This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Library General Public License as
published by the Free Software Foundation; either version 2 of
the License, or (at your option) any later version.
 
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Library General Public License for more details.
 
You should have received a copy of the GNU Library General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

</P>



<H1><A NAME="SEC1" HREF="mikmod_toc.html#TOC1">Introduction</A></H1>

<P>
The MikMod sound library is an excellent way for a programmer to add music
and sound effects to an application. It is a powerful and flexible library,
with a simple and easy-to-learn API.

</P>
<P>
Besides, the library is very portable and runs under a lot of Unices, as well
as under OS/2. Third party individuals also maintain ports on other systems,
including Windows (using DirectX), and BeOS.

</P>
<P>
MikMod is able to play a wide range of module formats, as well as digital sound
files. It can take advantage of particular features of your system, such as
sound redirection over the network. And due to its modular nature, the library
can be extended to support more sound or module formats, as well as new
hardware or other sound output capabilities, as they appear.

</P>


<H1><A NAME="SEC2" HREF="mikmod_toc.html#TOC2">Tutorial</A></H1>

<P>
This chapter will describe how to quickly incorporate MikMod's power into
your programs. It doesn't cover everything, but that's a start and I hope
it will help you understand the library's philosophy.

</P>
<P>
If you have a real tutorial to put here, you're welcome ! Please send it to
me...
</P>



<H2><A NAME="SEC3" HREF="mikmod_toc.html#TOC3">MikMod Concepts</A></H2>

<P>
MikMod's sound output is composed of several sound <EM>voices</EM> which are
mixed, either in software or in hardware, depending of your hardware
configuration. Simple sounds, like sound effects, use only one voice, whereas
sound modules, which are complex arrangements of sound effects, use several
voices.

</P>
<P>
MikMod's functions operate either globally, or at the voice level. Differences
in the handling of sound effects and modules are kept minimal, at least for
the programmer.

</P>
<P>
The sound playback is done by a <EM>sound driver</EM>. MikMod provides several
sound drivers: different hardware drivers, and some software drivers to
redirect sound in a file, or over the network. You can even add your own
driver, register it to make it known by the library, and select it.

</P>


<H2><A NAME="SEC4" HREF="mikmod_toc.html#TOC4">A Skeleton Program</A></H2>
<P>
<A NAME="IDX1"></A>
<A NAME="IDX2"></A>
<A NAME="IDX3"></A>

</P>
<P>
To use MikMod in your program, there are a few steps required:

</P>

<UL>
<LI>Include <TT>`mikmod.h'</TT> in your program.

<LI>Register the MikMod drivers you need.

<LI>Initialize the library with MikMod_Init() before using any other MikMod

function.
<LI>Give up resources with MikMod_Exit() at the end of your program, or before

when MikMod is not needed anymore.
<LI>Link your application with the MikMod sound library.

</UL>

<P>
Here's a program which meets all those conditions:

</P>

<PRE>
/* MikMod Sound Library example program: a skeleton */

#include &#60;mikmod.h&#62;

main()
{
	/* register all the drivers */
	MikMod_RegisterAllDrivers();

	/* initialize the library */
	MikMod_Init();

	/* we could play some sound here... */

	/* give up */
	MikMod_Exit();
}
</PRE>

<P>
This program would be compiled with the following command line:<A NAME="DOCF1" HREF="mikmod_foot.html#FOOT1">(1)</A>
<CODE>cc -o example example.c -lmikmod -ldl</CODE>

</P>
<P>
Although this programs produces no useful result, many things happen when you
run it. The call to <CODE>MikMod_RegisterAllDrivers</CODE> registers all the drivers
embedded in the MikMod library. Then, <CODE>MikMod_Init</CODE> chooses the more
adequate driver and initializes it. The program is now ready to produce sound.
When sound is not needed any more, <CODE>MikMod_Exit</CODE> is used to relinquish
memory and let other programs have access to the sound hardware.

</P>


<H2><A NAME="SEC5" HREF="mikmod_toc.html#TOC5">Playing Modules</A></H2>
<P>
<A NAME="IDX4"></A>
<A NAME="IDX5"></A>
<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
<A NAME="IDX8"></A>
<A NAME="IDX9"></A>
<A NAME="IDX10"></A>
<A NAME="IDX11"></A>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>
<A NAME="IDX14"></A>
<A NAME="IDX15"></A>

</P>
<P>
Our program is not really useful if it doesn't produce sound. Let's suppose
you've got this good old module, "Beyond music", in the file
<TT>`beyond_music.mod'</TT>. How about playing it ?

</P>
<P>
To do this, we'll use the following code:

</P>

<PRE>
/* MikMod Sound Library example program: a simple module player */

#include &#60;unistd.h&#62;
#include &#60;mikmod.h&#62;

main()
{
    MODULE *module;

    /* register all the drivers */
    MikMod_RegisterAllDrivers();

    /* register all the module loaders */
    MikMod_RegisterAllLoaders();

    /* initialize the library */
    md_mode|=DMODE_SOFT_MUSIC;
    if(MikMod_Init()) {
        fprintf(stderr,"Could not initialize sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* load module */
    module = Player_Load("beyond_music.mod",64,0);
    if (module) {
        /* start module */
        Player_Start(module);

        while(Player_Active()) {
            /* we're playing */
            usleep(10000);
            MikMod_Update();
        }

        Player_Stop();
        Player_Free(module);
    } else
        fprintf(stderr,"Could not load module, reason: %s\n",
                MikMod_strerror(MikMod_errno));

    /* give up */
    MikMod_Exit();
}
</PRE>

<P>
What's new here ? First, we've not only registered MikMod's device driver,
but also the module loaders. MikMod comes with a large choice of module
loaders, each one for a different module type. Since <EM>every</EM> loader is
called to determine the type of the module when we try to load them, you may
want to register only a few of them to save time. In our case, we don't matter,
so we happily register every module loader.

</P>
<P>
Then, there's an extra line before calling <CODE>MikMod_Init</CODE>. We change the
value of MikMod's variable <CODE>md_mode</CODE> to tell the library that we want the
module to be processed by the software. In fact, there's no hardware device
able to directly play modules, so all modules must be handled by software
mixing.

</P>
<P>
We'll ensure that <CODE>MikMod_Init</CODE> was successful. Note that, in case of
error, MikMod provides the variable <CODE>MikMod_errno</CODE>, an equivalent of
the C library <CODE>errno</CODE> for MikMod errors, and the function
<CODE>MikMod_strerror</CODE>, an equivalent to <CODE>strerror</CODE>.

</P>
<P>
Now onto serious business ! The module is loaded with the <CODE>Player_Load</CODE>
function, which takes the name of the module file, and the number of voices
afforded to the module. In this case, the module has only 4 channels, so 4
voices, but complex Impulse Tracker modules can have a lot of voices (as they
can have as many as 256 virtual channels with new note actions). Since empty
voices don't cost time to be processed, it is safe to use a big value, such as
64 or 128. The third parameter is the "curiosity" of the loader: if nonzero,
the loader will search for hidden parts in the module. However, only a few
module formats can embed hidden or non played parts, so we'll use 0 here.

</P>
<P>
Now that the module is ready to play, let's play it. We inform the player that
the current module is <CODE>module</CODE> with <CODE>Player_Start</CODE>. Playback starts,
but we have to update it on a regular basis. So there's a loop on the result
of the <CODE>Player_Active</CODE> function, which will tell us if the module has
finished. To update the sound, we simply call <CODE>MikMod_Update</CODE>.

</P>
<P>
After the module has finished, we tell the player its job is done with
<CODE>Player_Stop</CODE>, and we free the module with <CODE>Player_Free</CODE>.

</P>


<H2><A NAME="SEC6" HREF="mikmod_toc.html#TOC6">Playing Sound Effects</A></H2>
<P>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>
<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
<A NAME="IDX20"></A>
<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
<A NAME="IDX23"></A>
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>
<A NAME="IDX26"></A>

</P>
<P>
MikMod is not limited to playing modules, it can also play sound effects, that
is, module samples. It's a bit more complex than playing a module, because the
module player does a lot of things for us, but here we'll get more control over
what is actually played by the program. Let's look at an example:

</P>

<PRE>
/* MikMod Sound Library example program: sound effects */

#include &#60;unistd.h&#62;
#include &#60;mikmod.h&#62;

main()
{
    int i;
    /* sound effects */
    SAMPLE *sfx1,*sfx2;
    /* voices */
    int v1,v2;

    /* register all the drivers */
    MikMod_RegisterAllDrivers();

    /* initialize the library */
    md_mode|=DMODE_SOFT_SNDFX;
    if(MikMod_Init()) {
        fprintf(stderr,"Could not initialize sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* load samples */
    sfx1 = Sample_Load("first.wav");
    if(!sfx1) { 
        MikMod_Exit();
        fprintf(stderr,"Could not load the first sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }
    sfx2 = Sample_Load("second.wav");
    if(!sfx2) {
        Sample_Free(sfx1);
        MikMod_Exit();
        fprintf(stderr,"Could not load the second sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* reserve 2 voices for sound effects */
    MikMod_SetNumVoices(-1,2);

    /* get ready to play */
    MikMod_EnableOutput();

    /* play first sample */
    v1=Sample_Play(sfx1,0,0);
    for(i=0;i&#60;5;i++) {
        MikMod_Update();
        usleep(100000);
    }

    /* half a second later, play second sample */
    v2=Sample_Play(sfx2,0,0);
    do {
        MikMod_Update();
        usleep(100000);
    } while(!Voice_Stopped(v2));

    MikMod_DisableOutput();

    Sample_Free(sfx2);
    Sample_Free(sfx1);

    MikMod_Exit();
}
</PRE>

<P>
As in the previous example, we begin by registering the sound drivers and
initializing the library. We also ask for software mixing by modifying the
variable <CODE>md_mode</CODE><A NAME="DOCF2" HREF="mikmod_foot.html#FOOT2">(2)</A>.

</P>
<P>
It's time to load our files, with the <CODE>Sample_Load</CODE> function. Don't forget
to test the return value -- it looks ugly here on such a small example, but
it's a good practice...
</P>
<P>
Since we want to play two samples, we have to use at least two voices for this,
so we reserve them with a <CODE>MikMod_SetNumVoices</CODE> call. The first parameter
sets the number of module voices, and the second parameter the number of sound
effect voices. We don't want to set the number of module voices here (it's part
of the module player's duty), so we use the value <CODE>-1</CODE> to keep the current
value, and we reserve two sound effect voices.

</P>
<P>
Now we're ready to play, so we call <CODE>MikMod_EnableOutput</CODE> to make the
driver ready. Sound effects are played by the <CODE>Sample_Play</CODE> function.
You just have to specify which sample you want to play, the offset from which
you want to start, and the playback flags. More on this later. The function
returns the number of the voice associated to the sample.

</P>
<P>
We play the first sample for half a second, then we start to play the second
sample. Since we've reserved two channels, both samples play simultaneously. We
use the <CODE>Voice_Stopped</CODE> function to stop the playback: it returns the
current status of the voice argument, which is zero when the sample plays and
nonzero when it has finished. So the <CODE>do</CODE> loop will stop exactly when
the second sample is finished, regardless of the length of the first sample.

</P>
<P>
To finish, we get rid of the samples with <CODE>Sample_Free</CODE>.

</P>


<H2><A NAME="SEC7" HREF="mikmod_toc.html#TOC7">More Sound Effects</A></H2>
<P>
<A NAME="IDX27"></A>
<A NAME="IDX28"></A>
<A NAME="IDX29"></A>
<A NAME="IDX30"></A>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>
<A NAME="IDX33"></A>

</P>
<P>
Sound effects have some attributes that can be affected to control the playback.
These are speed, panning, and volume. Given a voice number, you can affect these
attributes with the <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetPanning</CODE> and
<CODE>Voice_SetVolume</CODE> functions.

</P>
<P>
In the previous example, we'll replace the actual sound code, located between
the calls to <CODE>MikMod_EnableOutput</CODE> and <CODE>MikMod_DisableOutput</CODE>, with
the following code:

</P>

<PRE>
    Sample_Play(sfx1,0,0);
    for(i=0;i&#60;5;i++) {
        MikMod_Update();
        usleep(100000);
    }
    v2=Sample_Play(sfx2,0,SFX_CRITICAL);
    i=0;
    do {
        MikMod_Update();
        usleep(100000);
        v1=Sample_Play(sfx1,0,0);
        Voice_SetVolume(v1,160);
        Voice_SetFrequency(v1,(sfx1-&#62;speed*(100+i))/100);
        Voice_SetPanning(v2,(i++&#38;1)?PAN_LEFT:PAN_RIGHT);
    } while(!Voice_Stopped(v2));
</PRE>

<P>
The first thing you'll notice, is the <CODE>SFX_CRITICAL</CODE> flag used to play the
second sample. Since the <CODE>do</CODE> loop will add another sample every 100
milliseconds, and we reserved only two voices, the oldest voice will be
cut each time this is necessary. Doing this would cut the second sample in the
second iteration of the loop. However, since we flagged this sound as
"critical", it won't be cut until it is finished or we stop it with a
<CODE>Voice_Stop</CODE> call. So the second sample will play fine, whereas the first
sample will be stopped every loop iteration.

</P>
<P>
Then, we choose to play the first sample a bit lower, with
<CODE>Voice_SetVolume</CODE>. Volume voices range from 0 (silence) to 256. In
this case we play the sample at 160. To make the sound look weird, we also
change its frequency with <CODE>Voice_SetFrequency</CODE>. The computation in the
example code makes the frequency more and more high (starting from the sample
frequency and then increasing from 1% each iteration).

</P>
<P>
And to demonstrate the <CODE>Voice_SetPanning</CODE> function, we change the panning
of the second sample at each iteration from the left to the right. The argument
can be one of the standard panning <CODE>PAN_LEFT</CODE>, <CODE>PAN_RIGHT</CODE>,
<CODE>PAN_MIDDLE</CODE> and <CODE>PAN_SURROUND</CODE><A NAME="DOCF3" HREF="mikmod_foot.html#FOOT3">(3)</A>, or a numeric value between 0 (<CODE>PAN_LEFT</CODE>) and
255 (<CODE>PAN_RIGHT</CODE>).

</P>


<H1><A NAME="SEC8" HREF="mikmod_toc.html#TOC8">Using the Library</A></H1>

<P>
This chapter describes the various parts of the library and their uses.

</P>



<H2><A NAME="SEC9" HREF="mikmod_toc.html#TOC9">Library Version</A></H2>
<P>
<A NAME="IDX34"></A>

</P>
<P>
If your program is dynamically linked with the MikMod library, you should check
which version of the library you're working with.
To do this, the library defines a few constants and a function to help you
determine if the current library is adequate for your needs or if it has to
be upgraded.

</P>
<P>
When your program includes <CODE>mikmod.h</CODE>, the following constants are
defined:

<UL>
<LI><CODE>LIBMIKMOD_VERSION_MAJOR</CODE> is equal to the major version number of

the library.
<LI><CODE>LIBMIKMOD_VERSION_MINOR</CODE> is equal to the minor version number of

the library.
<LI><CODE>LIBMIKMOD_REVISION</CODE> is equal to the revision number of the library.

<LI><CODE>LIBMIKMOD_VERSION</CODE> is the sum of <CODE>LIBMIKMOD_VERSION_MAJOR</CODE> shifted 16 times, <CODE>LIBMIKMOD_VERSION_MINOR</CODE> shifted 8 times, and

<CODE>LIBMIKMOD_REVISION</CODE>.
</UL>

<P>
So your program can tell with which version of the library it has been compiled
this way:

<PRE>
printf("Compiled with MikMod Sound Library version %ld.%ld.%ld\n",
       LIBMIKMOD_VERSION_MAJOR,
       LIBMIKMOD_VERSION_MINOR,
       LIBMIKMOD_REVISION);
</PRE>

<P>
The library defines the function <CODE>MikMod_GetVersion</CODE> which returns the
value of LIBMIKMOD_VERSION for the library. If this value is greater than or
equal to the value of LIBMIKMOD_VERSION for your program, your program will
work; otherwise, you'll have to inform the user that he has to upgrade the
library:

</P>

<PRE>
{
    long engineversion=MikMod_GetVersion();

    if (engineversion&#60;LIBMIKMOD_VERSION) {
        printf("MikMod library version (%ld.%ld.%ld) is too old.\n",
               (engineversion&#62;&#62;16)&#38;255,
               (engineversion&#62;&#62;8)&#38;255,
               (engineversion)&#38;255);
        printf("This programs requires at least version %ld.%ld.%ld\n",
               LIBMIKMOD_VERSION_MAJOR,
               LIBMIKMOD_VERSION_MINOR,
               LIBMIKMOD_REVISION);
        puts("Please upgrade your MikMod library.");
        exit(1);
    }
}
</PRE>



<H2><A NAME="SEC10" HREF="mikmod_toc.html#TOC10">Type Definitions</A></H2>
<P>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>

</P>
<P>
MikMod defines several data types to deal with modules and sample data.
These types have the same memory size on every platform MikMod has been ported
to.

</P>
<P>
These types are:

<UL>
<LI><CODE>CHAR</CODE> is a printable character. For now it is the same as the

<CODE>char</CODE> type, but in the future it may be wide char (Unicode) on some
platforms.
<LI><CODE>SBYTE</CODE> is a signed 8 bit number (can range from -128 to 127).

<LI><CODE>UBYTE</CODE> is an unsigned 8 bit number (can range from 0 to 255).

<LI><CODE>SWORD</CODE> is a signed 16 bit number (can range from -32768 to 32767).

<LI><CODE>UWORD</CODE> is an unsigned 16 bit number (can range from 0 to 65535).

<LI><CODE>SLONG</CODE> is a signed 32 bit number (can range from -2.147.483.648 to

2.147.483.647).
<LI><CODE>ULONG</CODE> is an unsigned 32 bit number (can range from 0 to

4.294.967.296).
<LI><CODE>BOOL</CODE> is a boolean value. A value of 0 means false, any other value

means true.
</UL>



<H2><A NAME="SEC11" HREF="mikmod_toc.html#TOC11">Error Handling</A></H2>
<P>
<A NAME="IDX43"></A>
<A NAME="IDX44"></A>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>

</P>
<P>
Although MikMod does its best to do its work, there are times where it can't.
For example, if you're trying to play a corrupted file, well, it can't.

</P>
<P>
A lot of MikMod functions return pointers or <CODE>BOOL</CODE> values. If the pointer
is <CODE>NULL</CODE> or the <CODE>BOOL</CODE> is 0 (false), an error has occurred.

</P>
<P>
MikMod errors are returned in the variable <CODE>MikMod_errno</CODE>. Each possible
error has a symbolic error code, beginning with <CODE>MMERR_</CODE>. For example, if
MikMod can't open a file, <CODE>MikMod_errno</CODE> will receive the value
<CODE>MMERR_OPENING_FILE</CODE>.

</P>
<P>
You can get an appropriate error message to display from the function
<CODE>MikMod_strerror</CODE>.

</P>
<P>
There is a second error variable named <CODE>MikMod_critical</CODE>. As its name
suggests, it is only set if the error lets the library in an unstable state.
This variable can only be set by the functions <CODE>MikMod_Init</CODE>, 
<CODE>MikMod_SetNumVoices</CODE> and <CODE>MikMod_EnableOutput</CODE>. If one of these
functions return an error and <CODE>MikMod_critical</CODE> is set, the library is left
in the uninitialized state (i.e. it was not initialized, or <CODE>MikMod_Exit</CODE>
was called).

</P>
<P>
If you prefer, you can use a callback function to get notified of errors. This
function must be prototyped as <CODE>void MyFunction(void)</CODE>. Then, call
<CODE>MikMod_RegisterHandler</CODE> with your function as argument to have it notified
when an error occurs. There can only be one callback function registered, but
<CODE>MikMod_RegisterHandler</CODE> will return you the previous handler, so you can
chain handlers if you want to.

</P>


<H2><A NAME="SEC12" HREF="mikmod_toc.html#TOC12">Library Initialization and Core Functions</A></H2>
<P>
<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>
<A NAME="IDX50"></A>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>
<A NAME="IDX55"></A>
<A NAME="IDX56"></A>
<A NAME="IDX57"></A>
<A NAME="IDX58"></A>
<A NAME="IDX59"></A>
<A NAME="IDX60"></A>

</P>
<P>
To initialize the library, you must register some sound drivers first. You can
either register all the drivers embedded in the library for your platform with
<CODE>MikMod_RegisterAllDrivers</CODE>, or register only some of them with
<CODE>MikMod_RegisterDriver</CODE>. If you choose to register the drivers manually,
you must be careful in their order, since <CODE>MikMod_Init</CODE> will try them in
the order you registered them. The <CODE>MikMod_RegisterAllDrivers</CODE> function
registers the network drivers first (for playing sound over the network), then
the hardware drivers, then the disk writers, and in last resort, the nosound
driver. Registering the nosound driver first would not be a very good
idea...

</P>
<P>
You can get some printable information regarding the registered drivers with
<CODE>MikMod_InfoDriver</CODE>; don't forget to call <CODE>free</CODE> on the returned
string when you don't need it anymore.

</P>
<P>
After you've registered your drivers, you can initialize the sound playback
with <CODE>MikMod_Init</CODE>. If you set the variable <CODE>md_device</CODE> to zero, which
is its default value, the driver will be autodetected, that is, the first driver
in the list that is available on the system will be used; otherwise only
the driver whose order in the list of the registered drivers is equal to
<CODE>md_device</CODE> will be tried.  If your playback settings, in the variables
<CODE>md_mixfreq</CODE> and <CODE>md_mode</CODE>, are not supported by the device,
<CODE>MikMod_Init</CODE> will fail.

</P>
<P>
You can then choose the number of voices you need with
<CODE>MikMod_SetNumVoices</CODE>, and activate the playback with
<CODE>MikMod_EnableOutput</CODE>.

</P>
<P>
Don't forget to call <CODE>MikMod_Update</CODE> as often as possible to process the
sound mixing. If necessary, fork a dedicated process to do this.

</P>
<P>
If you want to change playback settings, most of them can't be changed on the
fly. You'll need to stop the playback and reinitialize the driver. Use
<CODE>MikMod_Active</CODE> to check if there is still sound playing; in this case,
call <CODE>MikMod_DisableOutput</CODE> to end playback. Then, change your settings
and call <CODE>MikMod_Reset</CODE>. You're now ready to select your number of voices
and restart playback.

</P>
<P>
When your program ends, don't forget to stop playback and call
<CODE>MikMod_Exit</CODE> to leave the sound hardware in a coherent state.

</P>


<H2><A NAME="SEC13" HREF="mikmod_toc.html#TOC13">Samples and Voice Control</A></H2>
<P>
<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<A NAME="IDX63"></A>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
<A NAME="IDX66"></A>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>
<A NAME="IDX71"></A>

</P>
<P>
Currently, MikMod only supports uncompressed mono WAV files as samples. You can
load a sample by calling <CODE>Sample_Load</CODE> with a filename, or by calling
<CODE>Sample_LoadFP</CODE> with an open <CODE>FILE*</CODE> pointer. These functions return
a pointer to a <CODE>SAMPLE</CODE> structure, or <CODE>NULL</CODE> in case of error.

</P>
<P>
The <CODE>SAMPLE</CODE> structure has a few interesting fields:

<UL>
<LI><CODE>speed</CODE> contains the frequency of the sample.

<LI><CODE>volume</CODE> contains the volume of the sample, ranging from 0 (silence)

to 64.
<LI><CODE>panning</CODE> contains the panning position of the sample.

</UL>

<P>
Altering one of those fields will affect all voices currently playing the
sample. You can achieve the same result on a single voice with the functions
<CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetVolume</CODE> and <CODE>Voice_SetPanning</CODE>.

</P>
<P>
You can also make your sample loop by setting the fields <CODE>loopstart</CODE> and
<CODE>loopend</CODE> and or'ing <CODE>flags</CODE> with <CODE>SF_LOOP</CODE>. To compute your loop
values, the field <CODE>length</CODE> will be useful. However, you must know that
all the sample length are expressed in samples, i.e. 8 bits for an 8 bit sample,
and 16 bit for a 16 bit sample... Test <CODE>flags</CODE> for the value
<CODE>SF_16BITS</CODE> to know this.

</P>
<P>
If the common forward loop isn't enough, you can play with some other flags:
<CODE>SF_BIDI</CODE> will make your sample loop "ping pong" (back and forth), and
<CODE>SF_REVERSE</CODE> will make it play backwards.

</P>
<P>
To play your sample, use the <CODE>Sample_Play</CODE> function. This function
will return a voice number which enable you to use the <CODE>Voice_xx</CODE>
functions.

</P>
<P>
The sample will play until another sample takes over its voice (when you play
more samples than you reserved sound effect voices), unless it has been flagged
as <CODE>SFX_CRITICAL</CODE>. You can force it to stop with <CODE>Voice_Stop</CODE>, or you
can force another sample to take over this voice with <CODE>Voice_Play</CODE>;
however <CODE>Voice_Play</CODE> doesn't let you flag the new sample as critical.

</P>
<P>
Non looping samples will free their voice channel as soon as they are finished;
you can know the current playback position of your sample with
<CODE>Voice_GetPosition</CODE>. If it is zero, either the sample has finished playing
or it is just beginning; use <CODE>Voice_Stopped</CODE> to know.

</P>
<P>
When you don't need a sample anymore, don't forget to free its memory with
<CODE>Sample_Free</CODE>.

</P>


<H2><A NAME="SEC14" HREF="mikmod_toc.html#TOC14">Modules and Player Control</A></H2>
<P>
<A NAME="IDX72"></A>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>
<A NAME="IDX77"></A>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>
<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<A NAME="IDX96"></A>

</P>
<P>
As for the sound drivers, you have to register the module loaders you want to
use for MikMod to be able to load modules. You can either register all the
module loaders with <CODE>MikMod_RegisterAllLoaders</CODE>, or only a few of them with
<CODE>MikMod_RegisterLoader</CODE>. Be careful if you choose this solution, as the
15 instrument MOD loader has to be registered last, since loaders are called in
the order they were register to identify modules, and the detection of this
format is not fully reliable, so other modules might be mistaken as 15
instrument MOD files. 

</P>
<P>
You can get some printable information regarding the registered loaders with
<CODE>MikMod_InfoLoader</CODE>; don't forget to call <CODE>free</CODE> on the returned
string when you don't need it anymore.

</P>
<P>
Note that, contrary to the sound drivers, you can register module loaders at
any time, it doesn't matter.

</P>
<P>
For playlists, you might be interested in knowing the module title first, and
<CODE>Player_LoadTitle</CODE> will give you this information. Don't forget to
<CODE>free</CODE> the returned text when you don't need it anymore.

</P>
<P>
You can load a module either with <CODE>Player_Load</CODE> and the name of the
module, or with <CODE>Player_LoadFP</CODE> and an open <CODE>FILE*</CODE> pointer. These
functions also expect a maximal number of voices, and a curiosity flag. Unless
you have excellent reasons not to do so, choose a big limit, such as 64 or even
128 for complex Impulse Tracker modules. Both functions return a pointer to an
<CODE>MODULE</CODE> structure, or <CODE>NULL</CODE> if an error occurs.

</P>
<P>
You'll find some useful information in this structure:

<UL>
<LI><CODE>numchn</CODE> contains the number of module "real" channels.

<LI><CODE>numvoices</CODE> contains the number of voices reserved by the player for

the real channels and the virtual channels (NNA).
<LI><CODE>numpas</CODE> and <CODE>numpat</CODE> contain the number of song positions and

song patterns.
<LI><CODE>numins</CODE> and <CODE>numsmp</CODE> contain the number of instruments and

samples.
<LI><CODE>songname</CODE> contains the song title.

<LI><CODE>modtype</CODE> contains the name of the tracker used to create the song.

<LI><CODE>comment</CODE> contains the song comment, if it has one.

<LI><CODE>sngtime</CODE> contains the time elapsed in the module, in

2^-10 seconds (not exactly a millisecond).
<LI><CODE>sngspd</CODE> and <CODE>bpm</CODE> contain the song speed and tempo.

</UL>

<P>
Now that the module is loaded, you need to tell the module player that you want
to play this particular module with <CODE>Player_Start</CODE> (the player can only
play one module, but you can have several modules in memory). The playback
begins. Should you forget which module is playing, <CODE>Player_GetModule</CODE> will
return it to you.

</P>
<P>
You can change the current song position with the functions
<CODE>Player_NextPosition</CODE>, <CODE>Player_PrevPosition</CODE> and
<CODE>Player_SetPosition</CODE>, the speed with <CODE>Player_SetSpeed</CODE> and
<CODE>Player_SetTempo</CODE>, and the volume (ranging from 0 to 128) with
<CODE>Player_SetVolume</CODE>.

</P>
<P>
Playback can be paused or resumed with <CODE>Player_TogglePause</CODE>. Be sure to
check with <CODE>Player_Paused</CODE> that it isn't already in the state you want !

</P>
<P>
Fine player control is achieved by the functions <CODE>Player_Mute</CODE>,
<CODE>Player_UnMute</CODE> and <CODE>Player_ToggleMute</CODE> which can silence or resume
a set of module channels. The function <CODE>Player_Muted</CODE> will return the
state of a given channel. And if you want even more control, you can get the
voice corresponding to a module channel with <CODE>Player_GetChannelVoice</CODE> and
act directly on the voice.

</P>
<P>
Modules play only once, but can loop indefinitely if they are designed to do so.
You can change this behavior with the <CODE>wrap</CODE> and <CODE>loop</CODE> of the
<CODE>MODULE</CODE> structure; the first one, if set, will make the module restart
when it's finished, and the second one, if set, will prevent the module from
jumping backwards.

</P>
<P>
You can test if the module is still playing with <CODE>Player_Active</CODE>, and you
can stop it at any time with <CODE>Player_Stop</CODE>. When the module isn't needed
anymore, get rid of it with <CODE>Player_Free</CODE>.

</P>


<H1><A NAME="SEC15" HREF="mikmod_toc.html#TOC15">Library Reference</A></H1>

<P>
This chapter describes in more detail all the functions and variables provided
by the library. See section <A HREF="mikmod.html#SEC10">Type Definitions</A> for the basic type reference.

</P>



<H2><A NAME="SEC16" HREF="mikmod_toc.html#TOC16">Variable Reference</A></H2>



<H3><A NAME="SEC17" HREF="mikmod_toc.html#TOC17">Error Variables</A></H3>
<P>
The following variables are set by the library to return error information.

</P>
<DL COMPACT>

<DT><CODE>int MikMod_errno</CODE>
<DD>
<A NAME="IDX97"></A>
 
When an error occurs, this variable contains the error code.
See section <A HREF="mikmod.html#SEC27">Error Reference</A> for more information.
<A NAME="IDX98"></A>
<DT><CODE>BOOL MikMod_critical</CODE>
<DD>
When an error occurs, this variable informs of the severity of the error. Its
value has sense only if the value of <CODE>MikMod_errno</CODE> is different from zero.
If the value of <CODE>MikMod_critical</CODE> is zero, the error wasn't fatal and the
library is in a stable state. However, if it is nonzero, then the library can't
be used and has reseted itself to the uninitialized state. This often means
that the mixing parameters you choose were not supported by the driver, or that
it doesn't has enough voices for your needs if you called
<CODE>MikMod_SetNumVoices</CODE>.
</DL>



<H3><A NAME="SEC18" HREF="mikmod_toc.html#TOC18">Sound Settings</A></H3>
<P>
The following variables control the sound output parameters and their changes
take effect immediately.

</P>
<DL COMPACT>

<DT><CODE>UBYTE md_musicvolume</CODE>
<DD>
<A NAME="IDX99"></A>
 
Volume of the module. Allowed values range from
0 to 128. The default value is 128.
<A NAME="IDX100"></A>
<DT><CODE>UBYTE md_pansep</CODE>
<DD>
Stereo channels separation. Allowed values range
from 0 (no separation, thus mono sound) to 128 (full channel separation). The
default value is 128.
<A NAME="IDX101"></A>
<DT><CODE>UBYTE md_reverb</CODE>
<DD>
Amount of sound reverberation. Allowed values range
from 0 (no reverberation) to 15 (a rough estimate for chaos...). The
default value is 6.
<A NAME="IDX102"></A>
<DT><CODE>UBYTE md_sndfxvolume</CODE>
<DD>
Volume of the sound effects. Allowed values range
from 0 to 128. The default value is 128.
<A NAME="IDX103"></A>
<DT><CODE>UBYTE md_volume</CODE>
<DD>
Overall sound volume. Allowed values range from 0
to 128. The default value is 96.
</DL>



<H3><A NAME="SEC19" HREF="mikmod_toc.html#TOC19">Driver Settings</A></H3>
<P>
The following variables control more in-depth sound output parameters. Except
for some <CODE>md_mode</CODE> flags, their changes do not have any effect until you
call <CODE>MikMod_Init</CODE> or <CODE>MikMod_Reset</CODE>.

</P>
<DL COMPACT>

<DT><CODE>UWORD md_device</CODE>
<DD>
<A NAME="IDX104"></A>
 
This variable contains the order, in the list of the registered drivers, of the
sound driver which will be used for sound playback. This order is one-based; if
this variable is set to zero, the driver is autodetected, which means the list
is tested until a driver is present on the system. The default value is 0, thus
driver is autodetected.
<A NAME="IDX105"></A>
<DT><CODE>MDRIVER* md_driver</CODE>
<DD>
This variable points to the driver which is being used for sound playback, and
is undefined when the library is uninitialized (before <CODE>MikMod_Init</CODE> and
after <CODE>MikMod_Exit</CODE>). This variable is for information only, you should
never attempt to change its value. Use <CODE>md_driver</CODE> and <CODE>MikMod_Init</CODE>
(or <CODE>MikMod_Reset</CODE>) instead.
<A NAME="IDX106"></A>
<DT><CODE>UWORD md_mixfreq</CODE>
<DD>
Sound playback frequency, in hertz. High values
yield high sound quality, but need more computing power than lower values. The
default value is 44100 Hz, which is compact disc quality. Other common values
are 22100 Hz (radio quality), 11025 Hz (phone quality), and 8000 Hz (mu-law
quality).
<A NAME="IDX107"></A>
<DT><CODE>UWORD md_mode</CODE>
<DD>
This variable is a combination of several flags, to select which output mode
to select.
The following flags have a direct action to the sound output (i.e. changes take
effect immediately):
<DL COMPACT>

<DT><SAMP>`DMODE_INTERP'</SAMP>
<DD>
This flag, if set, enables the interpolated mixers. Interpolated mixing gives
better sound but takes a bit more time than standard mixing. If the library
is built with the high quality mixer, interpolated mixing is always enabled,
regardless of this flag.
<DT><SAMP>`DMODE_REVERSE'</SAMP>
<DD>
This flag, if set, exchanges the left and right stereo channels.
<DT><SAMP>`DMODE_SURROUND'</SAMP>
<DD>
This flag, if set, enables the surround mixers. Since surround mixing works
only for stereo sound, this flag has no effect if the sound playback is in
mono.
</DL>

<BR>The following flags aren't taken in account until the sound driver is changed
or reset:
<DL COMPACT>

<DT><SAMP>`DMODE_16BIT'</SAMP>
<DD>
This flag, if set, selects 16 bit sound mode. This mode yields better sound
quality, but needs twice more mixing time.
<DT><SAMP>`DMODE_SOFT_MUSIC'</SAMP>
<DD>
This flag, if set, selects software mixing of the module. Since no hardware
can play modules at the time of writing, this flag should always be set.
<DT><SAMP>`DMODE_SOFT_SNDFX'</SAMP>
<DD>
This flag, if set, selects software mixing of the sound effects. Currently,
no MikMod driver supports hardware mixing (although some DOS drivers used to
do this in the past...), so you'd better set this flag.
<DT><SAMP>`DMODE_STEREO'</SAMP>
<DD>
This flag, if set, selects stereo sound.
</DL>

<BR>The default value of this variable is <SAMP>`DMODE_STEREO | DMODE_SURROUND |
DMODE_16BITS | DMODE_SOFT_MUSIC | DMODE_SOFT_SNDFX'</SAMP>.
</DL>



<H2><A NAME="SEC20" HREF="mikmod_toc.html#TOC20">Structure Reference</A></H2>

<P>
Only the useful fields are described here; if a structure field is not
described, you must assume that it's an internal field which must not be
modified.

</P>


<H3><A NAME="SEC21" HREF="mikmod_toc.html#TOC21">Drivers</A></H3>
<P>
<A NAME="IDX108"></A>

</P>
<P>
The <CODE>MDRIVER</CODE> structure is not meant to be used by anything else than the
core of the library, but its first four fields contain useful information for
your programs:
<DL COMPACT>

<DT><CODE>CHAR* Name</CODE>
<DD>
Name of the driver, usually never more than 20 characters.
<DT><CODE>CHAR* Description</CODE>
<DD>
Description of the driver, usually never more than 50 characters.
<DT><CODE>UBYTE HardVoiceLimit</CODE>
<DD>
Maximum number of hardware voices for this driver, 0 if the driver has no
hardware mixing support.
<DT><CODE>UBYTE SoftVoiceLimit</CODE>
<DD>
Maximum number of software voices for this driver, 0 if the driver has no
software mixing support.
</DL>



<H3><A NAME="SEC22" HREF="mikmod_toc.html#TOC22">Modules</A></H3>
<P>
<A NAME="IDX109"></A>

</P>
<P>
The <CODE>MODULE</CODE> structure gathers all the necessary information needed to
play a module file, regardless of its initial format.

</P>


<H4><A NAME="SEC23" HREF="mikmod_toc.html#TOC23">General Module Information</A></H4>

<P>
The fields described in this section contain general information about the
module and should not be modified.

</P>
<DL COMPACT>

<DT><CODE>CHAR* songname</CODE>
<DD>
Name of the module.
<DT><CODE>CHAR* modtype</CODE>
<DD>
Type of the module (which tracker format).
<DT><CODE>CHAR* comment</CODE>
<DD>
Either the module comments, or NULL if the module doesn't have comments.
</DL>

<DL COMPACT>

<DT><CODE>UWORD flags</CODE>
<DD>
Several module flags or'ed together.
<DL COMPACT>

<DT><SAMP>`UF_INST'</SAMP>
<DD>
If set, the module has instruments and samples; otherwise, the
module has only samples.
<DT><SAMP>`UF_LINEAR'</SAMP>
<DD>
If set, slide periods are linear; otherwise, they are logarithmic.
<DT><SAMP>`UF_NNA'</SAMP>
<DD>
If set, module uses new note actions (NNA) and the <CODE>numvoices</CODE> field is
valid.
<DT><SAMP>`UF_S3MSLIDES'</SAMP>
<DD>
If set, module uses old-S3M style volume slides (slide processed every tick);
otherwise, it uses the standard style (slide processed every tick except the
first).
<DT><SAMP>`UF_XMPERIODS'</SAMP>
<DD>
If set, module uses XM-type periods; otherwise, it uses Amiga periods.
</DL>
<DT><CODE>UBYTE numchn</CODE>
<DD>
The number of channels in the module.
<DT><CODE>UBYTE numvoices</CODE>
<DD>
If the module uses NNA, and this variable is not zero, it contains the limit
of module voices; otherwise, the limit is set to the <CODE>maxchan</CODE> parameter
of the <CODE>Player_Loadxx</CODE> functions.
<DT><CODE>UWORD numpos</CODE>
<DD>
The number of sound positions in the module.
<DT><CODE>UWORD numpat</CODE>
<DD>
The number of patterns.
<DT><CODE>UWORD numins</CODE>
<DD>
The number of instruments.
<DT><CODE>UWORD numsmp</CODE>
<DD>
The number of samples.
</DL>

<DL COMPACT>

<DT><CODE>INSTRUMENT* instruments</CODE>
<DD>
Points to an array of instrument structures.
<DT><CODE>SAMPLE* samples</CODE>
<DD>
Points to an array of sample structures.
</DL>



<H4><A NAME="SEC24" HREF="mikmod_toc.html#TOC24">Playback Settings</A></H4>

<P>
The fields described here control the module playback and can be modified at
any time, unless otherwise specified.

</P>
<DL COMPACT>

<DT><CODE>UBYTE initspeed</CODE>
<DD>
The initial speed of the module (Protracker compatible). Valid range is 1-32.
<DT><CODE>UBYTE inittempo</CODE>
<DD>
The initial tempo of the module (Protracker compatible). Valid range is
32-255.
<DT><CODE>UBYTE initvolume</CODE>
<DD>
The initial overall volume of the module. Valid range is 0-128.
<DT><CODE>UWORD panning[]</CODE>
<DD>
The current channel panning positions. Only the first <CODE>numchn</CODE> values are
defined.
<DT><CODE>UBYTE chanvol[]</CODE>
<DD>
The current channel volumes. Only the first <CODE>numchn</CODE> values are defined.
<DT><CODE>UWORD bpm</CODE>
<DD>
The current tempo of the module. Use <CODE>Player_SetTempo</CODE> to change its value.
<DT><CODE>UBYTE sngspd</CODE>
<DD>
The current speed of the module. Use <CODE>Player_SetSpeed</CODE> to change its value.
<DT><CODE>UBYTE volume</CODE>
<DD>
The current overall volume of the module, in range 0-128. Use
<CODE>Player_SetVolume</CODE> to change its value.
</DL>

<DL COMPACT>

<DT><CODE>BOOL extspd</CODE>
<DD>
If zero, Protracker extended speed effect (in-module tempo modification) is
not processed. The default value is 1, which causes this effect to be processed.
However, some old modules might not play correctly if this effect is not
neutralized.
<DT><CODE>BOOL panflag</CODE>
<DD>
If zero, panning effects are not processed. The default value is 1, which cause
all panning effects to be processed. However, some old modules might not play
correctly if panning is not neutralized.
<DT><CODE>BOOL wrap</CODE>
<DD>
If nonzero, module wraps to its restart position when it is finished, to
play continuously. Default value is zero (play only once).
<DT><CODE>UBYTE reppos</CODE>
<DD>
The restart position of the module, when it wraps.
<DT><CODE>BOOL loop</CODE>
<DD>
If nonzero, all in-module loops are processed; otherwise, backward loops which
decrease the current position are not processed (i.e. only forward loops, and
backward loops in the same pattern, are processed). This ensures that the module
never loops endlessly. The default value is 1 (all loops are processed).
<DT><CODE>BOOL fadeout</CODE>
<DD>
If nonzero, volume fades out during when last position of the module is being
played. Default value us zero (no fadeout).
</DL>

<DL COMPACT>

<DT><CODE>UWORD patpos</CODE>
<DD>
Current position (row) in the pattern being played. Must not be changed.
<DT><CODE>SWORD sngpos</CODE>
<DD>
Current song position. Do not change this variable directly, use
<CODE>Player_NextPosition</CODE>, <CODE>Player_PrevPosition</CODE> or
<CODE>Player_SetPosition</CODE> instead.
<DT><CODE>ULONG sngtime</CODE>
<DD>
Elapsed song time, in 2^-10 seconds units (not exactly a
millisecond). To convert this value to seconds, divide by 1024.
</DL>



<H3><A NAME="SEC25" HREF="mikmod_toc.html#TOC25">Module Instruments</A></H3>
<P>
<A NAME="IDX110"></A>

</P>
<P>
Although the <CODE>INSTRUMENT</CODE> structure is intended for internal use, you
might need to know its name:

</P>
<DL COMPACT>

<DT><CODE>CHAR* insname</CODE>
<DD>
The instrument text, theoretically its name, but often a message line.
</DL>



<H3><A NAME="SEC26" HREF="mikmod_toc.html#TOC26">Samples</A></H3>
<P>
<A NAME="IDX111"></A>

</P>
<P>
The <CODE>SAMPLE</CODE> structure is used for sound effects and module samples as
well. You can play with the following fields:

</P>
<DL COMPACT>

<DT><CODE>SWORD panning</CODE>
<DD>
Panning value of the sample. Valid values range from PAN_LEFT (0) to
PAN_RIGHT (255), or PAN_SURROUND.
<DT><CODE>ULONG speed</CODE>
<DD>
Playing frequency of the sample, it hertz.
<DT><CODE>UBYTE volume</CODE>
<DD>
Sample volume. Valid range is 0-64.
<DT><CODE>UWORD flags</CODE>
<DD>
Several format flags or'ed together.

Format flags:
<DL COMPACT>

<DT><SAMP>`SF_16BITS'</SAMP>
<DD>
If set, sample data is 16 bit wide; otherwise, it is 8 bit wide.
<DT><SAMP>`SF_STEREO'</SAMP>
<DD>
If set, sample data is stereo (two channels); otherwise, it is mono.
<DT><SAMP>`SF_SIGNED'</SAMP>
<DD>
If set, sample data is made of signed values; otherwise, it is made of
unsigned values.
<DT><SAMP>`SF_BIG_ENDIAN'</SAMP>
<DD>
If set, sample data is in big--endian (Motorola) format; otherwise, it is in
little--endian (Intel) format.
<DT><SAMP>`SF_DELTA'</SAMP>
<DD>
If set, sample is stored as delta values (differences between two consecutive
samples); otherwise, sample is stored as sample values.
<DT><SAMP>`SF_ITPACKED'</SAMP>
<DD>
If set, sample data is packed with Impulse Tracker's compression method;
otherwise, sample is not packed.
</DL>

<BR>Playback flags:
<DL COMPACT>

<DT><SAMP>`SF_LOOP'</SAMP>
<DD>
If set, sample loops forward.
<DT><SAMP>`SF_BIDI'</SAMP>
<DD>
If set, sample loops "ping pong" (back and forth).
<DT><SAMP>`SF_REVERSE'</SAMP>
<DD>
If set, sample plays backwards.
</DL>
<DT><CODE>ULONG length</CODE>
<DD>
Length of the sample, in <EM>samples</EM>. The length of a sample is 8 bits
(1 byte) for a 8 bit sample, and 16 bits (2 bytes) for a 16 bit sample.
<DT><CODE>ULONG loopstart</CODE>
<DD>
Loop starting position, relative to the start of the sample, in samples.
<DT><CODE>ULONG loopend</CODE>
<DD>
Loop ending position, relative to the start of the sample, in samples.
</DL>



<H2><A NAME="SEC27" HREF="mikmod_toc.html#TOC27">Error Reference</A></H2>

<P>
The following errors are currently defined:

</P>


<H3><A NAME="SEC28" HREF="mikmod_toc.html#TOC28">General Errors</A></H3>
<DL COMPACT>

<DT><SAMP>`MMERR_OPENING_FILE'</SAMP>
<DD>
This error occurs when a file can not be opened, either for read access from a
<CODE>xx_Loadxx</CODE> function, or for write access from the disk writer drivers.
<DT><SAMP>`MMERR_OUT_OF_MEMORY'</SAMP>
<DD>
This error occurs when there is not enough virtual memory available to complete
the operation, or there is enough memory but the calling process would exceed
its memory limit. MikMod does not do any resource tuning, your program has to
use the <CODE>setrlimit</CODE> function to do this if it needs to load very huge
samples.
</DL>



<H3><A NAME="SEC29" HREF="mikmod_toc.html#TOC29">Sample Errors</A></H3>
<DL COMPACT>

<DT><SAMP>`MMERR_OUT_OF_HANDLES'</SAMP>
<DD>
This error occurs when your program reaches the limit of loaded samples,
currently defined as 384, which should be sufficient for most cases.
<DT><SAMP>`MMERR_SAMPLE_TOO_BIG'</SAMP>
<DD>
This error occurs when the memory allocation of the sample data yields the
error <CODE>MMERR_OUT_OF_MEMORY</CODE>.
<DT><SAMP>`MMERR_UNKNOWN_WAVE_TYPE'</SAMP>
<DD>
This error occurs when you're trying to load a sample which format is not
recognized.
</DL>



<H3><A NAME="SEC30" HREF="mikmod_toc.html#TOC30">Module Errors</A></H3>
<DL COMPACT>

<DT><SAMP>`MMERR_ITPACK_INVALID_DATA'</SAMP>
<DD>
This error occurs when a compressed module sample is corrupt.
<DT><SAMP>`MMERR_LOADING_HEADER'</SAMP>
<DD>
This error occurs when you're trying to load a module which has a corrupted
header, or is truncated.
<DT><SAMP>`MMERR_LOADING_PATTERN'</SAMP>
<DD>
This error occurs when you're trying to load a module which has corrupted
pattern data, or is truncated.
<DT><SAMP>`MMERR_LOADING_SAMPLEINFO'</SAMP>
<DD>
This error occurs when you're trying to load a module which has corrupted
sample information, or is truncated.
<DT><SAMP>`MMERR_LOADING_TRACK'</SAMP>
<DD>
This error occurs when you're trying to load a module which has corrupted
track data, or is truncated.
<DT><SAMP>`MMERR_MED_SYNTHSAMPLES'</SAMP>
<DD>
This error occurs when you're trying to load a MED module which has synthsounds
samples, which are currently not supported.
<DT><SAMP>`MMERR_NOT_A_MODULE'</SAMP>
<DD>
This error occurs when you're trying to load a module which format is not
recognized.
<DT><SAMP>`MMERR_NOT_A_STREAM'</SAMP>
<DD>
This error occurs when you're trying to load a sample with a sample which format
is not recognized.
</DL>



<H3><A NAME="SEC31" HREF="mikmod_toc.html#TOC31">Driver Errors</A></H3>
<P>
Generic driver errors
<DL COMPACT>

<DT><SAMP>`MMERR_DETECTING_DEVICE'</SAMP>
<DD>
This error occurs when the driver's sound device has not been detected.
<DT><SAMP>`MMERR_INITIALIZING_MIXER'</SAMP>
<DD>
This error occurs when MikMod's internal software mixer could not be initialized
properly.
<DT><SAMP>`MMERR_INVALID_DEVICE'</SAMP>
<DD>
This error occurs when the driver number (in <CODE>md_device</CODE>) is out of range.
<DT><SAMP>`MMERR_NON_BLOCK'</SAMP>
<DD>
This error occurs when the driver is unable to set the audio device in non
blocking mode.
<DT><SAMP>`MMERR_OPENING_AUDIO'</SAMP>
<DD>
This error occurs when the driver can not open sound device.
<DT><SAMP>`MMERR_16BIT_ONLY'</SAMP>
<DD>
This driver occurs when the sound device doesn't support non-16 bit linear
sound output, which are the requested settings.
</DL>
<P>
AudioFile driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_AF_AUDIO_PORT'</SAMP>
<DD>
This error occurs when the AudioFile driver can not find a suitable AudioFile
port.
</DL>
<P>
AIX driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_AIX_CONFIG_CONTROL'</SAMP>
<DD>
This error occurs when the "Control" step of the device configuration has
failed.
<DT><SAMP>`MMERR_AIX_CONFIG_INIT'</SAMP>
<DD>
This error occurs when the "Init" step of the device configuration has failed.
<DT><SAMP>`MMERR_AIX_CONFIG_START'</SAMP>
<DD>
This error occurs when the "Start" step of the device configuration has failed.
</DL>
<P>
HP-UX driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_HP_AUDIO_DESC'</SAMP>
<DD>
This error occurs when the HP driver can not get the audio hardware description.
<DT><SAMP>`MMERR_HP_AUDIO_OUTPUT'</SAMP>
<DD>
This error occurs when the HP driver can not select the audio output.
<DT><SAMP>`MMERR_HP_BUFFERSIZE'</SAMP>
<DD>
This error occurs when the HP driver can not set the transmission buffer size.
<DT><SAMP>`MMERR_HP_CHANNELS'</SAMP>
<DD>
This error occurs when the HP driver can not set the requested number of
channels.
<DT><SAMP>`MMERR_HP_GETGAINS'</SAMP>
<DD>
This error occurs when the HP driver can not get the audio gains.
<DT><SAMP>`MMERR_HP_SETGAINS'</SAMP>
<DD>
This error occurs when the HP driver can not set the audio gains.
<DT><SAMP>`MMERR_HP_SETSAMPLESIZE'</SAMP>
<DD>
This error occurs when the HP driver can not set the requested sample size.
<DT><SAMP>`MMERR_HP_SETSPEED'</SAMP>
<DD>
This error occurs when the HP driver can not set the requested sample rate.
</DL>
<P>
Open Sound System driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_OSS_SETFRAGMENT'</SAMP>
<DD>
This error occurs when the OSS driver can not set audio fragment size.
<DT><SAMP>`MMERR_OSS_SETSAMPLESIZE'</SAMP>
<DD>
This error occurs when the OSS driver can not set the requested sample size.
<DT><SAMP>`MMERR_OSS_SETSPEED'</SAMP>
<DD>
This error occurs when the OSS driver can not set the requested sample rate.
<DT><SAMP>`MMERR_OSS_SETSTEREO'</SAMP>
<DD>
This error occurs when the OSS driver can not set the requested number of
channels.
</DL>
<P>
SGI driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_SGI_MONO'</SAMP>
<DD>
This error occurs when the hardware only supports stereo sound.
<DT><SAMP>`MMERR_SGI_SPEED'</SAMP>
<DD>
This error occurs when the hardware does not support the requested sample rate.
<DT><SAMP>`MMERR_SGI_STEREO'</SAMP>
<DD>
This error occurs when the hardware only supports mono sound.
<DT><SAMP>`MMERR_SGI_16BIT'</SAMP>
<DD>
This error occurs when the hardware only supports 16 bit sound.
<DT><SAMP>`MMERR_SGI_8BIT'</SAMP>
<DD>
This error occurs when the hardware only supports 8 bit sound.
</DL>
<P>
Sun driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_SUN_INIT'</SAMP>
<DD>
This error occurs when the sound device initialization failed.
<DT><SAMP>`MMERR_SUN_16BIT_ULAW'</SAMP>
<DD>
This error occurs when you're trying to use mu-law encoding with 16 bit sound.
</DL>
<P>
OS/2 driver specific errors
<DL COMPACT>

<DT><SAMP>`MMERR_OS2_MIXSETUP'</SAMP>
<DD>
This error occurs when the DART driver can not set the mixing parameters.
<DT><SAMP>`MMERR_OS2_SEMAPHORE'</SAMP>
<DD>
This error occurs when the MMPM/2 driver can not create the semaphores needed
for playback.
<DT><SAMP>`MMERR_OS2_THREAD'</SAMP>
<DD>
This error occurs when the MMPM/2 driver can not create the thread needed for
playback.
<DT><SAMP>`MMERR_OS2_TIMER'</SAMP>
<DD>
This error occurs when the MMPM/2 driver can not create the timer needed for
playback.
</DL>



<H2><A NAME="SEC32" HREF="mikmod_toc.html#TOC32">Function Reference</A></H2>



<H3><A NAME="SEC33" HREF="mikmod_toc.html#TOC33">Library Core Functions</A></H3>

<P>
<A NAME="IDX112"></A>
<CODE>BOOL MikMod_Active(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns whether sound output is enabled or not.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
Sound output is disabled.
<DT><I>1</I>
<DD>
Sound output is enabled.
<DT><I>Notes</I>
<DD>
Calls to <CODE>MikMod_Update</CODE> will be ignored when sound output is disabled.
<DT><I>See also</I>
<DD>
<CODE>MikMod_DisableOutput</CODE>, <CODE>MikMod_EnableOutput</CODE>.
</DL>

<P>
<A NAME="IDX113"></A>
<CODE>void MikMod_DisableOutput(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function stops the sound mixing.
<DT><I>Notes</I>
<DD>
Calls to <CODE>MikMod_Update</CODE> will be ignored when sound output is disabled.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Active</CODE>, <CODE>MikMod_EnableOutput</CODE>.
</DL>

<P>
<A NAME="IDX114"></A>
<CODE>BOOL MikMod_EnableOutput(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function starts the sound mixing.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
Sound mixing is ready.
<DT><I>nonzero</I>
<DD>
An error occurred during the operation.
<DT><I>Notes</I>
<DD>
Calls to <CODE>MikMod_Update</CODE> will be ignored when sound output is disabled.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Active</CODE>, <CODE>MikMod_DisableOutput</CODE>.
</DL>

<P>
<A NAME="IDX115"></A>
<CODE>void MikMod_Exit(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function deinitializes the sound hardware and frees all the memory and
resources used by MikMod.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Init</CODE>, <CODE>MikMod_Reset</CODE>.
</DL>

<P>
<A NAME="IDX116"></A>
<CODE>long MikMod_GetVersion(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns the version number of the library.
<DT><I>Result</I>
<DD>
The version number, encoded as follows:
<CODE>(maj&#60;&#60;16)|(min&#60;&#60;8)|(rev)</CODE>,
where <SAMP>`maj'</SAMP> is the major version number, <SAMP>`min'</SAMP> is the minor version
number, and <SAMP>`rev'</SAMP> is the revision number.
</DL>

<P>
<A NAME="IDX117"></A>
<CODE>CHAR* MikMod_InfoDriver(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns a formatted list of the registered drivers in a buffer.
<DT><I>Result</I>
<DD>
A pointer to a text buffer, or <CODE>NULL</CODE> if no drivers are registered.
<DT><I>Notes</I>
<DD>
The buffer is created with <CODE>malloc</CODE>; the caller must free it when it is
no longer necessary.
<DT><I>See also</I>
<DD>
<CODE>MikMod_RegisterDriver</CODE>, <CODE>MikMod_RegisterAllDrivers</CODE>.
</DL>

<P>
<A NAME="IDX118"></A>
<CODE>CHAR* MikMod_InfoLoader(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns a formatted list of the registered module loaders in a
buffer.
<DT><I>Result</I>
<DD>
A pointer to a text buffer, or <CODE>NULL</CODE> if no loaders are registered.
<DT><I>Notes</I>
<DD>
The buffer is created with <CODE>malloc</CODE>; the caller must free it when it is
no longer necessary.
<DT><I>See also</I>
<DD>
<CODE>MikMod_RegisterLoader</CODE>, <CODE>MikMod_RegisterAllLoaders</CODE>.
</DL>

<P>
<A NAME="IDX119"></A>
<CODE>BOOL MikMod_Init(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function performs the library initialization, including the sound driver
choice and configuration, and all the necessary memory allocations.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
Initialization was successful.
<DT><I>nonzero</I>
<DD>
An error occurred during initialization.
<DT><I>Notes</I>
<DD>
When the initialization fails, the library uses the nosound sound driver to
let other the other MikMod functions work without crashing the application.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Exit</CODE>, <CODE>MikMod_Reset</CODE>.
</DL>

<P>
<A NAME="IDX120"></A>
<CODE>void MikMod_RegisterAllDrivers(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function registers all the available drivers.
<DT><I>See also</I>
<DD>
<CODE>MikMod_InfoDriver</CODE>, <CODE>MikMod_RegisterDriver</CODE>.
</DL>

<P>
<A NAME="IDX121"></A>
<CODE>void MikMod_RegisterAllLoaders(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function registers all the available module loaders.
<DT><I>See also</I>
<DD>
<CODE>MikMod_InfoLoader</CODE>, <CODE>MikMod_RegisterLoader</CODE>.
</DL>

<P>
<A NAME="IDX122"></A>
<CODE>void MikMod_RegisterDriver(struct MDRIVER* newdriver)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function adds the specified driver to the internal list of usable
drivers.
<DT><I>Parameters</I>
<DD>
<DT><I>newdriver</I>
<DD>
A pointer to the <CODE>MDRIVER</CODE> structure identifying the driver.
<DT><I>Notes</I>
<DD>
It is safe to register the same driver several times, although it will not
be duplicated in the list.<BR>
You should register all the drivers you need before calling <CODE>MikMod_Init</CODE>.
If you want to register all the available drivers, use
<CODE>MikMod_RegisterAllDrivers</CODE> instead.
<DT><I>See also</I>
<DD>
<CODE>MikMod_InfoDriver</CODE>, <CODE>MikMod_RegisterAllDrivers</CODE>.
</DL>

<P>
<A NAME="IDX123"></A>
<CODE>MikMod_handler_t MikMod_RegisterErrorHandler(MikMod_handler_t newhandler)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function selects the function which should be called in case of error.
<DT><I>Parameters</I>
<DD>
<DT><I>newhandler</I>
<DD>
The new error callback function.
<DT><I>Result</I>
<DD>
The previous error callback function, or <CODE>NULL</CODE> if there was none.
<DT><I>Notes</I>
<DD>
<CODE>MikMod_handler_t</CODE> is defined as <CODE>void(*function)(void)</CODE>, this means
your error function has the following prototype:
<CODE>void MyErrorHandler(void)</CODE><BR>
The error callback function is called when errors are detected, but not
always immediately (the library has to resume to a stable state before calling
your callback).
</DL>

<P>
<A NAME="IDX124"></A>
<CODE>void MikMod_RegisterLoader(struct MLOADER* newloader)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function adds the specified module loader to the internal list of usable
module loaders.
<DT><I>Parameters</I>
<DD>
<DT><I>newloader</I>
<DD>
A pointer to the <CODE>MLOADER</CODE> structure identifying the loader.
<DT><I>Notes</I>
<DD>
It is safe to register the same loader several times, although it will not be
duplicated in the list.<BR>
You should register all the loaders you need before calling <CODE>Player_Load</CODE>
or <CODE>Player_LoadFP</CODE>. If you want to register all the available module
loaders, use <CODE>MikMod_RegisterAllLoaders</CODE> instead.<BR>
The 15 instrument module loader (<CODE>load_m15</CODE>) should always be registered
last.
<DT><I>See also</I>
<DD>
<CODE>MikMod_InfoLoader</CODE>, <CODE>MikMod_RegisterAllLoaders</CODE>.
</DL>

<P>
<A NAME="IDX125"></A>
<CODE>MikMod_player_t MikMod_RegisterPlayer(MikMod_player_t newplayer)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function selects the function which should be used to process module
playback.
<DT><I>Parameters</I>
<DD>
<DT><I>newplayer</I>
<DD>
The new playback function
<DT><I>Result</I>
<DD>
The previous playback function.
<DT><I>Notes</I>
<DD>
<CODE>MikMod_player_t</CODE> is defined as <CODE>void(*function)(void)</CODE>, this means
your player function has the following prototype:
<CODE>void MyPlayer(void)</CODE><BR>
The player function is called every module tick to process module playback.
The rate at which the player function is called is controlled by the sound
driver, and is computed by the following equation:<BR>
(bpm*50)/125 calls per second, which means every 125000/(bpm*50)
milliseconds. The <CODE>bpm</CODE> value is the tempo of the module and can
change from its initial value when requested by the module.<BR>
When changing the playback function, you should make sure that you chain to the
default MikMod playback function, otherwise you won't get module sound
anymore...
<DT><I>Example</I>
<DD>

<PRE>
    MikMod_player_t oldroutine;

    void MyPlayer(void)
    {
        oldroutine();
        /* your stuff here */
        ...;
    }

    main()
    {
        ...
        /* Register our player */
        oldroutine=MikMod_RegisterPlayer(MyPlayer);
        ...
    }
</PRE>

</DL>

<P>
<A NAME="IDX126"></A>
<CODE>BOOL MikMod_Reset(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function resets MikMod and reinitialize the sound hardware.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
Reinitialization was successful.
<DT><I>nonzero</I>
<DD>
An error occurred during reinitialization.
<DT><I>Notes</I>
<DD>
Use this function when you have changed the global configuration variables:
<CODE>md_device</CODE> and <CODE>md_mixfreq</CODE>, or one of the <CODE>md_mode</CODE> flags
which require sound reinitialization. Sound playback will continue as soon as
the driver is ready.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Exit</CODE>, <CODE>MikMod_Init</CODE>.
</DL>

<P>
<A NAME="IDX127"></A>
<CODE>BOOL MikMod_SetNumVoices(int musicvoices,int samplevoices)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the number of mixed voices which can be used for music
and sound effects playback.
<DT><I>Parameters</I>
<DD>
<DT><I>musicvoices</I>
<DD>
The number of voices to reserve for music playback.
<DT><I>samplevoices</I>
<DD>
The number of voices to reserve for sound effects.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
Initialization was successful.
<DT><I>nonzero</I>
<DD>
An error occurred during initialization.
<DT><I>Notes</I>
<DD>
A value of <CODE>-1</CODE> for any of the parameters will retain the current number
of reserved voices.<BR>
The maximum number of voices vary from driver to driver (hardware drivers
often have a limit of 32 to 64 voices, whereas the software drivers handle
255 voices). If your settings exceed the driver's limit, they will be truncated.
<DT><I>See also</I>
<DD>
<CODE>MikMod_Init</CODE>, <CODE>MikMod_Reset</CODE>.
</DL>

<P>
<A NAME="IDX128"></A>
<CODE>void MikMod_Update(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This routine should be called on a regular basis to update the sound.
<DT><I>Notes</I>
<DD>
The sound output buffer is filled each time this function is called; if you
use a large buffer, you don't need to call this routine as frequently as with
a smaller buffer, but you get a bigger shift between the sound being played
and the reported state of the player, since the player is always a buffer
ahead of the playback.<BR>
If you play low quality sound (for example, mono 8 bit 11kHz sound), you
only need to call this routine a few times per second. However, for high quality
sound (stereo 16 bit 44kHz), this rate increases to a few hundred times
per second, but never more, due to the minimal buffer size constraint imposed
to the sound drivers.<BR>
If you plan on modifying voice information with the <CODE>Voice_xx</CODE> functions,
you should do this before calling <CODE>MikMod_Update</CODE>.
</DL>

<P>
<A NAME="IDX129"></A>
<CODE>char* MikMod_strerror(int errno)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function associates a descriptive message to an error code.
<DT><I>Parameters</I>
<DD>
<DT><I>errno</I>
<DD>
The MikMod error code.
<DT><I>Result</I>
<DD>
A pointer to a string describing the error.
</DL>



<H3><A NAME="SEC34" HREF="mikmod_toc.html#TOC34">Module Player Functions</A></H3>

<P>
<A NAME="IDX130"></A>
<CODE>BOOL Player_Active(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns whether the module player is active or not.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
No module is playing.
<DT><I>nonzero</I>
<DD>
A module is currently playing.
<DT><I>Notes</I>
<DD>
This function will still report that the player is active if the playing module
is paused.
<DT><I>See also</I>
<DD>
<CODE>Player_Paused</CODE>, <CODE>Player_TogglePause</CODE>, <CODE>Player_Start</CODE>, <CODE>Player_Stop</CODE>
</DL>

<P>
<A NAME="IDX131"></A>
<CODE>void Player_Free(MODULE* module)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function stops the module if it is playing and unloads it from memory.
<DT><I>Parameters</I>
<DD>
<DT><I>module</I>
<DD>
The module to free.
<DT><I>See also</I>
<DD>
<CODE>Player_Load</CODE>, <CODE>Player_LoadFP</CODE>.
</DL>

<P>
<A NAME="IDX132"></A>
<CODE>int Player_GetChannelVoice(int channel)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function determines the voice corresponding to the specified module
channel.
<DT><I>Parameters</I>
<DD>
<DT><I>channel</I>
<DD>
The module channel to use.
<DT><I>Result</I>
<DD>
The number of the voice corresponding to the module channel.
<DT><I>Notes</I>
<DD>
If the module channel has NNAs, the number will correspond to the main channel
voice.
<DT><I>See also</I>
<DD>
<CODE>Voice_SetPanning</CODE>, <CODE>Voice_SetVolume</CODE>, <CODE>Player_Mute</CODE>, <CODE>Player_ToggleMute</CODE>, <CODE>Player_Unmute</CODE>.
</DL>

<P>
<A NAME="IDX133"></A>
<CODE>MODULE* Player_GetModule(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns the module currently being played.
<DT><I>Result</I>
<DD>
A pointer to the <CODE>MODULE</CODE> being played, or <CODE>NULL</CODE> if no module is
playing.
<DT><I>See also</I>
<DD>
<CODE>Player_Stop</CODE>, <CODE>Player_Start</CODE>.
</DL>

<P>
<A NAME="IDX134"></A>
<CODE>MODULE* Player_Load(CHAR* filename,int maxchan,BOOL curious)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function loads a music module.
<DT><I>Parameters</I>
<DD>
<DT><I>filename</I>
<DD>
The name of the module file.
<DT><I>maxchan</I>
<DD>
The maximum number of channels the song is allowed to request from the mixer.
<DT><I>curious</I>
<DD>
The curiosity level to use.
<DT><I>Result</I>
<DD>
A pointer to a <CODE>MODULE</CODE> structure, or <CODE>NULL</CODE> if an error occurs.
<DT><I>Notes</I>
<DD>
If the curiosity level is set to zero, the module will be loaded normally.
However, if it is nonzero, the following things occur:

<UL>
<LI>pattern positions occurring after the "end of song" marker in S3M and

IT modules are loaded, and the end of song is set to the last position.
<LI>hidden extra patterns are searched in MOD modules, and if found, played

after the last "official" pattern.
<LI>MED modules with synthsounds are loaded without causing the

<CODE>MMERR_MED_SYNTHSAMPLES</CODE>, and synthsounds are mapped to an empty sample.
</UL>

<DT><I>See also</I>
<DD>
<CODE>Player_Free</CODE>, <CODE>Player_LoadFP</CODE>, <CODE>Player_LoadTitle</CODE>, <CODE>Player_Start</CODE>.
</DL>

<P>
<A NAME="IDX135"></A>
<CODE>MODULE* Player_LoadFP(FILE* file,int maxchan,BOOL curious)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function loads a music module.
<DT><I>Parameters</I>
<DD>
<DT><I>file</I>
<DD>
An open file, at the position where the module starts.
<DT><I>maxchan</I>
<DD>
The maximum number of channels the song is allowed to request from the mixer.
<DT><I>curious</I>
<DD>
The curiosity level to use.
<DT><I>Result</I>
<DD>
A pointer to a <CODE>MODULE</CODE> structure, or <CODE>NULL</CODE> if an error occurs.
<DT><I>Notes</I>
<DD>
The file is left open, at the same position as before the function call.<BR>
If the curiosity level is set to zero, the module will be loaded normally.
However, if it is nonzero, the following things occur:

<UL>
<LI>pattern positions occurring after the "end of song" marker in S3M and

IT modules are loaded, and the end of song is set to the last position.
<LI>hidden extra patterns are searched in MOD modules, and if found, played

after the last "official" pattern.
<LI>MED modules with synthsounds are loaded without causing the

<CODE>MMERR_MED_SYNTHSAMPLES</CODE>, and synthsounds are mapped to an empty sample.
</UL>

<DT><I>See also</I>
<DD>
<CODE>Player_Free</CODE>, <CODE>Player_Load</CODE>, <CODE>Player_LoadTitle</CODE>, <CODE>Player_Start</CODE>.
</DL>

<P>
<A NAME="IDX136"></A>
<CODE>MODULE* Player_LoadTitle(CHAR* filename)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function retrieves the title of a module file.
<DT><I>Parameters</I>
<DD>
<DT><I>filename</I>
<DD>
The name of the module file.
<DT><I>Result</I>
<DD>
A pointer to the song title, or <CODE>NULL</CODE> if either the module has no title
or an error has occurred.
<DT><I>Notes</I>
<DD>
The title buffer is created with <CODE>malloc</CODE>; the caller must free it when it
is no longer necessary.
<DT><I>See also</I>
<DD>
<CODE>Player_Load</CODE>, <CODE>Player_LoadFP</CODE>.
</DL>

<P>
<A NAME="IDX137"></A>
<CODE>void Player_Mute(SLONG operation,...)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function mutes a single module channel, or a range of module channels.
<DT><I>Parameters</I>
<DD>
<DT><I>operation</I>
<DD>
Either the number of a module channel to mute (starting from zero), or an
operation code. In the latter case, two extra parameters are needed to
determine the range of channels.
<DT><I>Notes</I>
<DD>
If the operation is <CODE>MUTE_INCLUSIVE</CODE>, the two channel numbers delimit the
range and are part of the range ; otherwise, if the operation is
<CODE>MUTE_EXCLUSIVE</CODE>, they are outside of the range.
<DT><I>Example</I>
<DD>

<PRE>
    /* mute channel 10 */
    Player_Mute(10);
    /* mute channels 2 to 5 */
    Player_Mute(MUTE_INCLUSIVE,2,5);
    /* mute channels 7 to 9 */
    Player_Mute(MUTE_EXCLUSIVE,6,10);
</PRE>

<DT><I>See also</I>
<DD>
<CODE>Player_Muted</CODE>, <CODE>Player_ToggleMute</CODE>, <CODE>Player_Unmute</CODE>.
</DL>

<P>
<A NAME="IDX138"></A>
<CODE>BOOL Player_Muted(UBYTE channel)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function determines whether a module channel is muted or not.
<DT><I>Parameters</I>
<DD>
<DT><I>channel</I>
<DD>
The module channel to test (starting from zero).
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
The channel is not muted.
<DT><I>1</I>
<DD>
The channel is muted.
<DT><I>See also</I>
<DD>
<CODE>Player_Mute</CODE>, <CODE>Player_ToggleMute</CODE>, <CODE>Player_Unmute</CODE>.
</DL>

<P>
<A NAME="IDX139"></A>
<CODE>void Player_NextPosition(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function jumps to the next position in the module.
<DT><I>Notes</I>
<DD>
All playing samples and active song voices are cut to avoid hanging notes.
<DT><I>See also</I>
<DD>
<CODE>Player_PrevPosition</CODE>, <CODE>Player_SetPosition</CODE>.
</DL>

<P>
<A NAME="IDX140"></A>
<CODE>BOOL Player_Paused(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function determines whether the module is paused or not.
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
The module is not paused.
<DT><I>1</I>
<DD>
The module is paused.
<DT><I>See also</I>
<DD>
<CODE>Player_TogglePause</CODE>.
</DL>

<P>
<A NAME="IDX141"></A>
<CODE>void Player_PrevPosition(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function jumps to the previous position in the module.
<DT><I>Notes</I>
<DD>
All playing samples and active song voices are cut to avoid hanging notes.
<DT><I>See also</I>
<DD>
<CODE>Player_NextPosition</CODE>, <CODE>Player_SetPosition</CODE>.
</DL>

<P>
<A NAME="IDX142"></A>
<CODE>void Player_SetPosition(UWORD position)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function jumps to the specified position in the module.
<DT><I>Parameters</I>
<DD>
<DT><I>position</I>
<DD>
The pattern position to jump to.
<DT><I>Notes</I>
<DD>
All playing samples and active song voices are cut to avoid hanging notes.
<DT><I>See also</I>
<DD>
<CODE>Player_NextPosition</CODE>, <CODE>Player_PrevPosition</CODE>.
</DL>

<P>
<A NAME="IDX143"></A>
<CODE>void Player_SetSpeed(UWORD speed)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the module speed.
<DT><I>Parameters</I>
<DD>
<DT><I>speed</I>
<DD>
The new module speed, in the range 1-32.
<DT><I>See also</I>
<DD>
<CODE>Player_SetTempo</CODE>.
</DL>

<P>
<A NAME="IDX144"></A>
<CODE>void Player_SetTempo(UWORD tempo)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the module tempo.
<DT><I>Parameters</I>
<DD>
<DT><I>tempo</I>
<DD>
The new module tempo, in the range 32-255.
<DT><I>See also</I>
<DD>
<CODE>Player_SetSpeed</CODE>.
</DL>

<P>
<A NAME="IDX145"></A>
<CODE>void Player_SetVolume(SWORD volume)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the module volume.
<DT><I>Parameters</I>
<DD>
<DT><I>volume</I>
<DD>
The new overall module playback volume, in the range 0-128.
</DL>

<P>
<A NAME="IDX146"></A>
<CODE>void Player_Start(MODULE* module)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function starts the specified module playback.
<DT><I>Parameters</I>
<DD>
<DT><I>module</I>
<DD>
The module to play.
<DT><I>Notes</I>
<DD>
If another module is playing, it will be stopped and the new module will play.
<DT><I>See also</I>
<DD>
<CODE>Player_Stop</CODE>.
</DL>

<P>
<A NAME="IDX147"></A>
<CODE>void Player_Stop(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function stops the currently playing module.
<DT><I>See also</I>
<DD>
<CODE>Player_Start</CODE>.
</DL>

<P>
<A NAME="IDX148"></A>
<CODE>void Player_ToggleMute(SLONG operation,...)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function changes the muted status of a single module channel, or a range
of module channels.
<DT><I>Parameters</I>
<DD>
<DT><I>operation</I>
<DD>
Either the number of a module channel to work on (starting from zero), or an
operation code. In the latter case, two extra parameters are needed to
determine the range of channels.
<DT><I>Notes</I>
<DD>
If the operation is <CODE>MUTE_INCLUSIVE</CODE>, the two channel numbers delimit the
range and are part of the range ; otherwise, if the operation is
<CODE>MUTE_EXCLUSIVE</CODE>, they are outside of the range.
<DT><I>Example</I>
<DD>

<PRE>
    /* toggle mute on channel 10 */
    Player_ToggleMute(10);
    /* toggle mute on channels 2 to 5 */
    Player_ToggleMute(MUTE_INCLUSIVE,2,5);
    /* toggle mute on channels 7 to 9 */
    Player_ToggleMute(MUTE_EXCLUSIVE,6,10);
</PRE>

<DT><I>See also</I>
<DD>
<CODE>Player_Mute</CODE>, <CODE>Player_Muted</CODE>, <CODE>Player_Unmute</CODE>.
</DL>

<P>
<A NAME="IDX149"></A>
<CODE>void Player_TogglePause(void)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function toggles the playing/paused status of the module.
<DT><I>Notes</I>
<DD>
Calls to <CODE>Player_xx</CODE> functions still have effect when the module is paused.
<DT><I>See also</I>
<DD>
<CODE>Player_Paused</CODE>, <CODE>Player_Start</CODE>, <CODE>Player_Stop</CODE>.
</DL>

<P>
<A NAME="IDX150"></A>
<CODE>void Player_Unmute(SLONG operation,...)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function unmutes a single module channel, or a range of module channels.
<DT><I>Parameters</I>
<DD>
<DT><I>operation</I>
<DD>
Either the number of a module channel to unmute (starting from zero), or an
operation code. In the latter case, two extra parameters are needed to
determine the range of channels.
<DT><I>Notes</I>
<DD>
If the operation is <CODE>MUTE_INCLUSIVE</CODE>, the two channel numbers delimit the
range and are part of the range ; otherwise, if the operation is
<CODE>MUTE_EXCLUSIVE</CODE>, they are outside of the range.
<DT><I>Example</I>
<DD>

<PRE>
    /* unmute channel 10 */
    Player_Unmute(10);
    /* unmute channels 2 to 5 */
    Player_Unmute(MUTE_INCLUSIVE,2,5);
    /* unmute channels 7 to 9 */
    Player_Unmute(MUTE_EXCLUSIVE,6,10);
</PRE>

<DT><I>See also</I>
<DD>
<CODE>Player_Mute</CODE>, <CODE>Player_Muted</CODE>, <CODE>Player_ToggleMute</CODE>.
</DL>



<H3><A NAME="SEC35" HREF="mikmod_toc.html#TOC35">Sample Functions</A></H3>

<P>
<A NAME="IDX151"></A>
<CODE>void Sample_Free(SAMPLE* sample)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function unloads a sample from memory.
<DT><I>Parameters</I>
<DD>
<DT><I>sample</I>
<DD>
The sample to free.
<DT><I>See also</I>
<DD>
<CODE>Sample_Load</CODE>, <CODE>Sample_LoadFP</CODE>.
</DL>

<P>
<A NAME="IDX152"></A>
<CODE>SAMPLE* Sample_Load(CHAR* filename)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function loads a sample.
<DT><I>Parameters</I>
<DD>
<DT><I>filename</I>
<DD>
The sample filename.
<DT><I>Result</I>
<DD>
A pointer to a <CODE>SAMPLE</CODE> structure, or <CODE>NULL</CODE> if an error has occurred.
<DT><I>See also</I>
<DD>
<CODE>Sample_Free</CODE>, <CODE>Sample_LoadFP</CODE>.
</DL>

<P>
<A NAME="IDX153"></A>
<CODE>SAMPLE* Sample_LoadFP(FILE* file)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function loads a sample.
<DT><I>Parameters</I>
<DD>
<DT><I>file</I>
<DD>
An open file, at the position where the sample starts.
<DT><I>Result</I>
<DD>
A pointer to a <CODE>SAMPLE</CODE> structure, or <CODE>NULL</CODE> if an error has occurred.
<DT><I>Notes</I>
<DD>
The file is left open, at the same position as before the function call.
<DT><I>See also</I>
<DD>
<CODE>Sample_Free</CODE>, <CODE>Sample_Load</CODE>.
</DL>

<P>
<A NAME="IDX154"></A>
<CODE>SBYTE Sample_Play(SAMPLE* sample,ULONG start,UBYTE flags)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function plays a sample as a sound effect.
<DT><I>Parameters</I>
<DD>
<DT><I>sample</I>
<DD>
The sample to play.
<DT><I>start</I>
<DD>
The starting position (in samples).
<DT><I>flags</I>
<DD>
Either zero, for normal sound effects, or <CODE>SFX_CRITICAL</CODE>, for critical
sound effects which must not be interrupted.
<DT><I>Result</I>
<DD>
The voice number corresponding to the voice which will play the sample.
<DT><I>Notes</I>
<DD>
Each new sound effect is played on a new voice. When all voices are taken,
the oldest sample which was not marked as critical is cut and its voice is
used for the new sample. Critical samples are not cut unless all the voices
are taken with critical samples and you attempt to play yet another critical
sample. Use <CODE>Voice_Stop</CODE> to force the end of a critical sample.
<DT><I>See also</I>
<DD>
<CODE>MikMod_SetNumVoices</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetPanning</CODE>, <CODE>Voice_SetVolume</CODE>, <CODE>Voice_Stop</CODE>.
</DL>



<H3><A NAME="SEC36" HREF="mikmod_toc.html#TOC36">Voice Functions</A></H3>

<P>
<A NAME="IDX155"></A>
<CODE>SLONG Voice_GetPosition(SBYTE voice)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns the sample position (in samples) of the sample
currently playing on the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to get sample position (starting from zero).
<DT><I>Result</I>
<DD>
The current play location of the sample playing on the specified voice, or zero
if the position can not be determined or if no sample is currently playing on
the voice.
<DT><I>Notes</I>
<DD>
This function may not work with some drivers (especially for hardware mixed
voices). In this case, it returns always zero.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>.
</DL>

<P>
<A NAME="IDX156"></A>
<CODE>void Voice_Play(SBYTE voice,SAMPLE* sample,ULONG start)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
Start a new sample in the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be processed (starting from zero).
<DT><I>sample</I>
<DD>
The sample to play.
<DT><I>start</I>
<DD>
The starting position (in samples).
<DT><I>Notes</I>
<DD>
The sample will be played at the volume, panning and frequency settings of the
voice, regardless or the sample characteristics.<BR>
The sample played this way gets the same "critical" status as the sample
which was previously played on this voice.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetPanning</CODE>, <CODE>Voice_SetVolume</CODE>.
</DL>

<P>
<A NAME="IDX157"></A>
<CODE>ULONG Voice_RealVolume(SBYTE voice)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns the actual playing volume of the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to analyze (starting from zero).
<DT><I>Result</I>
<DD>
The real volume of the voice when the function was called, in the range 0-65535,
not related to the volume constraint specified with <CODE>Voice_SetVolume</CODE>.
<DT><I>Notes</I>
<DD>
This function may not work with some drivers (especially for hardware mixed
voices). In this case, it returns always zero.<BR>
Also note that the real volume computation is not a trivial process and takes
some CPU time.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetVolume</CODE>.
</DL>

<P>
<A NAME="IDX158"></A>
<CODE>void Voice_SetFrequency(SBYTE voice,ULONG frequency)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the frequency (pitch) of the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be processed (starting from zero).
<DT><I>frequency</I>
<DD>
The new frequency of the voice, in hertz.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetPanning</CODE>, <CODE>Voice_SetVolume</CODE>, <CODE>Voice_Stop</CODE>.
</DL>

<P>
<A NAME="IDX159"></A>
<CODE>void Voice_SetPanning(SBYTE voice,ULONG panning)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the panning position of the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be processed (starting from zero).
<DT><I>panning</I>
<DD>
The new panning position of the voice.
<DT><I>Notes</I>
<DD>
Panning can vary between 0 (<CODE>PAN_LEFT</CODE>) and 255 (<CODE>PAN_RIGHT</CODE>). Center
is 127 (<CODE>PAN_CENTER</CODE>. Surround sound can be enabled by specifying the
special value <CODE>PAN_SURROUND</CODE>.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetVolume</CODE>, <CODE>Voice_Stop</CODE>.
</DL>

<P>
<A NAME="IDX160"></A>
<CODE>void Voice_SetVolume(SBYTE voice,UWORD volume)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function sets the volume of the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be processed (starting from zero).
<DT><I>volume</I>
<DD>
The new volume of the voice, in the range 0-256.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetPanning</CODE>, <CODE>Voice_Stop</CODE>.
</DL>

<P>
<A NAME="IDX161"></A>
<CODE>void Voice_Stop(SBYTE voice)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function stops the playing sample of the specified voice.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be processed (starting from zero).
<DT><I>Notes</I>
<DD>
After the call to <CODE>Voice_Stop</CODE>, the function <CODE>Voice_Stopped</CODE> will
return nonzero (true) for the voice. If you want to silence the voice without
stopping the playback, use <CODE>Voice_SetVolume(voice,0)</CODE> instead.
<DT><I>See also</I>
<DD>
<CODE>Sample_Play</CODE>, <CODE>Voice_Play</CODE>, <CODE>Voice_SetFrequency</CODE>, <CODE>Voice_SetPanning</CODE>, <CODE>Voice_SetVolume</CODE>.
</DL>

<P>
<A NAME="IDX162"></A>
<CODE>BOOL Voice_Stopped(SBYTE voice)</CODE>
<DL COMPACT>

<DT><I>Description</I>
<DD>
This function returns whether the voice is active or not.
<DT><I>Parameters</I>
<DD>
<DT><I>voice</I>
<DD>
The number of the voice to be checked (starting from zero).
<DT><I>Result</I>
<DD>
<DT><I>0</I>
<DD>
The voice is stopped or has no sample assigned.
<DT><I>nonzero</I>
<DD>
The voice is playing a sample.
<DT><I>Notes</I>
<DD>
This function may not work with some drivers (especially for hardware mixed
voices). In this case, its return value is undefined.
<DT><I>See also</I>
<DD>
<CODE>Voice_Stop</CODE>.
</DL>



<H2><A NAME="SEC37" HREF="mikmod_toc.html#TOC37">Loader Reference</A></H2>



<H3><A NAME="SEC38" HREF="mikmod_toc.html#TOC38">Module Loaders</A></H3>

<P>
MikMod presents a large choice of module loaders, for the most common formats
as well as for some less-known exotic formats.

</P>
<DL COMPACT>

<DT><CODE>load_669</CODE>
<DD>
This loader recognizes "Composer 669" and "Unis 669" modules. The 669
and "Extended 669" formats were among the first PC module formats. They
do not have a wide range of effects, but support up to 32 channels.<BR>
"Composer 669" was written by Tran of Renaissance, a.k.a. Tomasz Pytel and
released in 1992. "Unis 669 Composer" was written by Jason Nunn and released
in 1994.
<DT><CODE>load_amf</CODE>
<DD>
This loader recognizes the "Advanced Module Format", which is the internal
module format of the "DOS Sound and Music Interface" (DSMI) library. This
format has the same limitations as the S3M format. The most famous DSMI
application was DMP, the Dual Module Player.<BR>
DMP and the DSMI library were written by Otto Chrons. DSMI was first released
in 1993.
<DT><CODE>load_dsm</CODE>
<DD>
This loader recognizes the internal DSIK format, which is the internal module
format of the "Digital Sound Interface Kit" (DSIK) library, the ancester of
the SEAL library. This format has the same limitations as the S3M format.<BR>
The DSIK library was written by Carlos Hasan and released in 1994.
<DT><CODE>load_far</CODE>
<DD>
This loader recognizes "Farandole" modules. These modules can be up to 16
channels and have Protracker comparable effects.<BR>
The Farandole composer was written by Daniel Potter and released in 1994. 
<DT><CODE>load_imf</CODE>
<DD>
This loader recognizes "Imago Orpheus" modules. This format is roughly
equivalent to the XM format, but with two effects columns instead of a volume
column and an effect column.<BR>
Imago Orpheus was written by Lutz Roeder and released in 1994.
<DT><CODE>load_it</CODE>
<DD>
This loader recognizes "Impulse Tracker" modules, currently the most powerful
format. These modules support up to 64 real channels, and up to 256 virtual
channels with the "New Note Action" feature. Besides, it has the widest range
of effects, and supports 16 bit samples as well as surround sound.<BR>
"Impulse Tracker" was written by Jeffrey Lim and released in 1996.
<DT><CODE>load_med</CODE>
<DD>
This loader recognizes "OctaMED" modules. These modules are comparable to
Protracker modules, but can embed "synthsounds", which are midi-like
instruments.<BR>
"MED" and later "OctaMED" were written by Teijo Kinnunen. "MED" was
released in 1989, and "OctaMED" was released in 1992.
<DT><CODE>load_m15</CODE>
<DD>
This loader recognizes the old 15 instrument modules, created by "Ultimate
Soundtracker", "Soundtracker" and the first versions of "Protracker".<BR>
Since this format was one of the first module formats, developed in 1987, it
does not have any signature field, which makes it hard to detect reliably,
because of its similarities with later module formats.
<DT><CODE>load_mod</CODE>
<DD>
This loader recognizes the standard 31 instrument modules, created by
"Protracker" or Protracker-compatible programs. The original Protracker
format was limited to 4 channels, but other trackers like "TakeTracker",
"StarTracker" or "Oktalyzer" afforded more channels.<BR>
Although it is now technically obsolete, this format is still widely used, due
to its playback simplicity (on the adequate hardware, the Amiga).
<DT><CODE>load_mtm</CODE>
<DD>
This loader recognizes the "MultiTracker Module Editor" modules. The MTM
format has up to 32 channels, and protracker comparable effects. It was
intended to replace "Composer 669".
The "MultiTracker Module Editor" was written by Starscream of Renaissance,
a.k.a. Daniel Goldstein and released in late 1993.
<DT><CODE>load_stm</CODE>
<DD>
This loader recognizes "ScreamTracker" modules. "ScreamTracker" was the
first PC tracker, as well as the first PC module format. Loosely inspired by
the "SoundTracker" format, it does not have as many effects as Protracker,
although it supports 31 instruments and 4 channels.<BR>
"ScreamTracker" was written by PSI of Future Crew, a.k.a. Sami Tammilehto.
<DT><CODE>load_stx</CODE>
<DD>
This loader recognizes "STMIK 0.2" modules. "STMIK" (the Scream Tracker
Music Interface Kit) was a module playing library distributed by Future Crew
to play Scream Tracker module in games and demos. It uses an intermediate format
between STM and S3M and comes with a tool converting STM modules to STX.<BR>
"STMIK" was written by PSI of Future Crew, a.k.a. Sami Tammilehto.
<DT><CODE>load_s3m</CODE>
<DD>
This loader recognizes "ScreamTracker 3" modules. This version was a huge
improvement over the original "ScreamTracker". It supported 32 channels
(although the tracker only let you work on 16), up to 99 instruments, and a
large choice of effects.<BR>
"ScreamTracker 3" was written by PSI of Future Crew, a.k.a. Sami
Tammilehto, and released in 1994.
<DT><CODE>load_ult</CODE>
<DD>
This loader recognizes "UltraTracker" modules. They are mostly similar to
Protracker modules, but support two effects per channel.<BR>
"UltraTracker" was written by MAS of Prophecy, a.k.a. Marc Andre Schallehn,
and released in 1993.
<DT><CODE>load_xm</CODE>
<DD>
This loader recognizes "FastTracker 2" modules. This format was designed from
scratch, instead of creating yet another Protracker variation. It was the first
format using instruments as well as samples, and envelopes for finer effects.<BR>
FastTracker 2 was written by Fredrik Huss and Magnus Hogdahl, and released in
1994.
</DL>



<H3><A NAME="SEC39" HREF="mikmod_toc.html#TOC39">Sample Loaders</A></H3>

<P>
Currently, the only file type than can be loaded as a sample is the RIFF
WAVE file. Stereo or compressed WAVE files are not supported yet.

</P>


<H2><A NAME="SEC40" HREF="mikmod_toc.html#TOC40">Driver Reference</A></H2>



<H3><A NAME="SEC41" HREF="mikmod_toc.html#TOC41">Network Drivers</A></H3>

<P>
These drivers send the generated sound over the network to a server program,
which sends the sound to the real sound hardware. The server program can be
on the same machine than your program, but MikMod does not have access to the
hardware. Network drivers only support software mixing.

</P>
<DL COMPACT>

<DT><CODE>drv_AF</CODE>
<DD>
This driver works with the "Digital AudioFile" library.<BR>
Start the server on the machine you want, set its hostname in the
<SAMP>`AUDIOFILE'</SAMP> environment variable, and MikMod is ready to send it sound.
<DT><CODE>drv_esd</CODE>
<DD>
This driver works with the "Enlightened Sound Daemon".<BR>
Start the esd daemon on the machine you want, set its hostname in the
<SAMP>`ESPEAKER'</SAMP> environment variable, and MikMod is ready to send it sound.
</DL>



<H3><A NAME="SEC42" HREF="mikmod_toc.html#TOC42">Hardware Drivers</A></H3>

<P>
These drivers access to the sound hardware of the machine they run on.
Depending on your Unix flavor, you'll end with one or more drivers from this
list:

</P>
<DL COMPACT>

<DT><CODE>drv_aix</CODE>
<DD>
This driver is only available under AIX, and access its audio device.<BR>
This driver only supports software mixing.
<DT><CODE>drv_alsa</CODE>
<DD>
This driver is only available under Linux, and requires the ALSA driver to be
compiled for your kernel version.<BR>
This driver only supports software mixing, but a future version of the driver
might be able to use the hardware capabilities of some sound cards.
<DT><CODE>drv_dart</CODE>
<DD>
This driver is only available under OS/2 3 and higher (Warp), and uses the
"Direct Audio Real-Time" interface.<BR>
This driver only supports software mixing.
<DT><CODE>drv_hp</CODE>
<DD>
This driver is only available under HP-UX, and access its audio device.<BR>
This driver only supports software mixing.
<DT><CODE>drv_os2l</CODE>
<DD>
<DT><CODE>drv_os2s</CODE>
<DD>
These drivers are only available under OS/2 3 and higher (Warp), and OS/2 2.x
with MMPM/2. The first one uses a large buffer, whereas the second one uses
a smaller buffer to keep the player status close to the actual sound output.<BR>
This driver only supports software mixing.
<DT><CODE>drv_oss</CODE>
<DD>
This driver is available under any Unix with the Open Sound System drivers
installed. Linux and FreeBSD also come with the OSS/Lite driver (the
non-commercial version of OSS) and can make use of this driver.<BR>
This driver only supports software mixing.
<DT><CODE>drv_sgi</CODE>
<DD>
This driver is only available under IRIX, and uses the SGI audio library.<BR>
This driver only supports software mixing.
<DT><CODE>drv_sun</CODE>
<DD>
This driver is only available under Unices which implement SunOS-like audio
device interfaces, that is, SunOS, Solaris, NetBSD and OpenBSD.<BR>
This driver only supports software mixing.
</DL>



<H3><A NAME="SEC43" HREF="mikmod_toc.html#TOC43">Disk Writer Drivers</A></H3>

<P>
These drivers work on any machine, since the generated sound is not sent to
hardware, but written in a file. Disk writer drivers only support software
mixing.

</P>
<DL COMPACT>

<DT><CODE>drv_raw</CODE>
<DD>
This driver outputs the sound date in a file named <TT>`music.raw'</TT> in the
current directory. The file has no header and only contains the sound output.
<DT><CODE>drv_wav</CODE>
<DD>
This driver outputs the sound data in a RIFF WAVE file named <TT>`music.wav'</TT> in
the current directory.
</DL>



<H3><A NAME="SEC44" HREF="mikmod_toc.html#TOC44">Other Drivers</A></H3>

<P>
These drivers are of little interest, but are handy sometimes.

</P>
<DL COMPACT>

<DT><CODE>drv_stdout</CODE>
<DD>
This driver outputs the sound data to the program's standard output. To avoid
inconvenience, the data will not be output if the standard output is a terminal,
thus you have to pipe it through another command or to redirect it to a file.
Using this driver and redirecting to a file is equivalent to using the
<CODE>drv_raw</CODE> disk writer.<BR>
This driver only supports software mixing.
<DT><CODE>drv_nos</CODE>
<DD>
This driver doesn't produce sound at all, and will work on any machine.<BR>
Since it does not have to produce sound, it supports both hardware and software
mixing, with as many hardware voices as you like.
</DL>



<H1><A NAME="SEC45" HREF="mikmod_toc.html#TOC45">Function Index</A></H1>
<P>
<H2>m</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX47">MikMod_Active</A>, <A HREF="mikmod.html#IDX112">MikMod_Active</A>
<LI><A HREF="mikmod.html#IDX16">MikMod_DisableOutput</A>, <A HREF="mikmod.html#IDX48">MikMod_DisableOutput</A>, <A HREF="mikmod.html#IDX113">MikMod_DisableOutput</A>
<LI><A HREF="mikmod.html#IDX17">MikMod_EnableOutput</A>, <A HREF="mikmod.html#IDX49">MikMod_EnableOutput</A>, <A HREF="mikmod.html#IDX114">MikMod_EnableOutput</A>
<LI><A HREF="mikmod.html#IDX1">MikMod_Exit</A>, <A HREF="mikmod.html#IDX4">MikMod_Exit</A>, <A HREF="mikmod.html#IDX18">MikMod_Exit</A>, <A HREF="mikmod.html#IDX50">MikMod_Exit</A>, <A HREF="mikmod.html#IDX115">MikMod_Exit</A>
<LI><A HREF="mikmod.html#IDX34">MikMod_GetVersion</A>, <A HREF="mikmod.html#IDX116">MikMod_GetVersion</A>
<LI><A HREF="mikmod.html#IDX51">MikMod_InfoDriver</A>, <A HREF="mikmod.html#IDX117">MikMod_InfoDriver</A>
<LI><A HREF="mikmod.html#IDX72">MikMod_InfoLoader</A>, <A HREF="mikmod.html#IDX118">MikMod_InfoLoader</A>
<LI><A HREF="mikmod.html#IDX2">MikMod_Init</A>, <A HREF="mikmod.html#IDX5">MikMod_Init</A>, <A HREF="mikmod.html#IDX19">MikMod_Init</A>, <A HREF="mikmod.html#IDX52">MikMod_Init</A>, <A HREF="mikmod.html#IDX119">MikMod_Init</A>
<LI><A HREF="mikmod.html#IDX3">MikMod_RegisterAllDrivers</A>, <A HREF="mikmod.html#IDX6">MikMod_RegisterAllDrivers</A>, <A HREF="mikmod.html#IDX20">MikMod_RegisterAllDrivers</A>, <A HREF="mikmod.html#IDX53">MikMod_RegisterAllDrivers</A>, <A HREF="mikmod.html#IDX120">MikMod_RegisterAllDrivers</A>
<LI><A HREF="mikmod.html#IDX7">MikMod_RegisterAllLoaders</A>, <A HREF="mikmod.html#IDX73">MikMod_RegisterAllLoaders</A>, <A HREF="mikmod.html#IDX121">MikMod_RegisterAllLoaders</A>
<LI><A HREF="mikmod.html#IDX54">MikMod_RegisterDriver</A>, <A HREF="mikmod.html#IDX122">MikMod_RegisterDriver</A>
<LI><A HREF="mikmod.html#IDX43">MikMod_RegisterErrorHandler</A>, <A HREF="mikmod.html#IDX123">MikMod_RegisterErrorHandler</A>
<LI><A HREF="mikmod.html#IDX74">MikMod_RegisterLoader</A>, <A HREF="mikmod.html#IDX124">MikMod_RegisterLoader</A>
<LI><A HREF="mikmod.html#IDX75">MikMod_RegisterPlayer</A>, <A HREF="mikmod.html#IDX125">MikMod_RegisterPlayer</A>
<LI><A HREF="mikmod.html#IDX55">MikMod_Reset</A>, <A HREF="mikmod.html#IDX126">MikMod_Reset</A>
<LI><A HREF="mikmod.html#IDX21">MikMod_SetNumVoices</A>, <A HREF="mikmod.html#IDX56">MikMod_SetNumVoices</A>, <A HREF="mikmod.html#IDX127">MikMod_SetNumVoices</A>
<LI><A HREF="mikmod.html#IDX10">MikMod_strerror</A>, <A HREF="mikmod.html#IDX129">MikMod_strerror</A>
<LI><A HREF="mikmod.html#IDX8">MikMod_Update</A>, <A HREF="mikmod.html#IDX22">MikMod_Update</A>, <A HREF="mikmod.html#IDX27">MikMod_Update</A>, <A HREF="mikmod.html#IDX57">MikMod_Update</A>, <A HREF="mikmod.html#IDX128">MikMod_Update</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX11">Player_Active</A>, <A HREF="mikmod.html#IDX76">Player_Active</A>, <A HREF="mikmod.html#IDX130">Player_Active</A>
<LI><A HREF="mikmod.html#IDX12">Player_Free</A>, <A HREF="mikmod.html#IDX77">Player_Free</A>, <A HREF="mikmod.html#IDX131">Player_Free</A>
<LI><A HREF="mikmod.html#IDX78">Player_GetChannelVoice</A>, <A HREF="mikmod.html#IDX132">Player_GetChannelVoice</A>
<LI><A HREF="mikmod.html#IDX79">Player_GetModule</A>, <A HREF="mikmod.html#IDX133">Player_GetModule</A>
<LI><A HREF="mikmod.html#IDX13">Player_Load</A>, <A HREF="mikmod.html#IDX80">Player_Load</A>, <A HREF="mikmod.html#IDX134">Player_Load</A>
<LI><A HREF="mikmod.html#IDX81">Player_LoadFP</A>, <A HREF="mikmod.html#IDX135">Player_LoadFP</A>
<LI><A HREF="mikmod.html#IDX82">Player_LoadTitle</A>, <A HREF="mikmod.html#IDX136">Player_LoadTitle</A>
<LI><A HREF="mikmod.html#IDX83">Player_Mute</A>, <A HREF="mikmod.html#IDX137">Player_Mute</A>
<LI><A HREF="mikmod.html#IDX84">Player_Muted</A>, <A HREF="mikmod.html#IDX138">Player_Muted</A>
<LI><A HREF="mikmod.html#IDX85">Player_NextPosition</A>, <A HREF="mikmod.html#IDX139">Player_NextPosition</A>
<LI><A HREF="mikmod.html#IDX86">Player_Paused</A>, <A HREF="mikmod.html#IDX140">Player_Paused</A>
<LI><A HREF="mikmod.html#IDX87">Player_PrevPosition</A>, <A HREF="mikmod.html#IDX141">Player_PrevPosition</A>
<LI><A HREF="mikmod.html#IDX88">Player_SetPosition</A>, <A HREF="mikmod.html#IDX142">Player_SetPosition</A>
<LI><A HREF="mikmod.html#IDX89">Player_SetSpeed</A>, <A HREF="mikmod.html#IDX143">Player_SetSpeed</A>
<LI><A HREF="mikmod.html#IDX90">Player_SetTempo</A>, <A HREF="mikmod.html#IDX144">Player_SetTempo</A>
<LI><A HREF="mikmod.html#IDX91">Player_SetVolume</A>, <A HREF="mikmod.html#IDX145">Player_SetVolume</A>
<LI><A HREF="mikmod.html#IDX14">Player_Start</A>, <A HREF="mikmod.html#IDX92">Player_Start</A>, <A HREF="mikmod.html#IDX146">Player_Start</A>
<LI><A HREF="mikmod.html#IDX15">Player_Stop</A>, <A HREF="mikmod.html#IDX93">Player_Stop</A>, <A HREF="mikmod.html#IDX147">Player_Stop</A>
<LI><A HREF="mikmod.html#IDX94">Player_ToggleMute</A>, <A HREF="mikmod.html#IDX148">Player_ToggleMute</A>
<LI><A HREF="mikmod.html#IDX95">Player_TogglePause</A>, <A HREF="mikmod.html#IDX149">Player_TogglePause</A>
<LI><A HREF="mikmod.html#IDX96">Player_UnMute</A>
<LI><A HREF="mikmod.html#IDX150">Player_Unmute</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX24">Sample_Free</A>, <A HREF="mikmod.html#IDX68">Sample_Free</A>, <A HREF="mikmod.html#IDX151">Sample_Free</A>
<LI><A HREF="mikmod.html#IDX25">Sample_Load</A>, <A HREF="mikmod.html#IDX69">Sample_Load</A>, <A HREF="mikmod.html#IDX152">Sample_Load</A>
<LI><A HREF="mikmod.html#IDX70">Sample_LoadFP</A>, <A HREF="mikmod.html#IDX153">Sample_LoadFP</A>
<LI><A HREF="mikmod.html#IDX26">Sample_Play</A>, <A HREF="mikmod.html#IDX28">Sample_Play</A>, <A HREF="mikmod.html#IDX71">Sample_Play</A>, <A HREF="mikmod.html#IDX154">Sample_Play</A>
</DIR>
<H2>v</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX61">Voice_GetPosition</A>, <A HREF="mikmod.html#IDX155">Voice_GetPosition</A>
<LI><A HREF="mikmod.html#IDX62">Voice_Play</A>, <A HREF="mikmod.html#IDX156">Voice_Play</A>
<LI><A HREF="mikmod.html#IDX157">Voice_RealVolume</A>
<LI><A HREF="mikmod.html#IDX29">Voice_SetFrequency</A>, <A HREF="mikmod.html#IDX65">Voice_SetFrequency</A>, <A HREF="mikmod.html#IDX158">Voice_SetFrequency</A>
<LI><A HREF="mikmod.html#IDX30">Voice_SetPanning</A>, <A HREF="mikmod.html#IDX66">Voice_SetPanning</A>, <A HREF="mikmod.html#IDX159">Voice_SetPanning</A>
<LI><A HREF="mikmod.html#IDX31">Voice_SetVolume</A>, <A HREF="mikmod.html#IDX67">Voice_SetVolume</A>, <A HREF="mikmod.html#IDX160">Voice_SetVolume</A>
<LI><A HREF="mikmod.html#IDX32">Voice_Stop</A>, <A HREF="mikmod.html#IDX63">Voice_Stop</A>, <A HREF="mikmod.html#IDX161">Voice_Stop</A>
<LI><A HREF="mikmod.html#IDX23">Voice_Stopped</A>, <A HREF="mikmod.html#IDX33">Voice_Stopped</A>, <A HREF="mikmod.html#IDX64">Voice_Stopped</A>, <A HREF="mikmod.html#IDX162">Voice_Stopped</A>
</DIR>

</P>


<H1><A NAME="SEC46" HREF="mikmod_toc.html#TOC46">Type and Variable Index</A></H1>
<P>
<H2>b</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX35">BOOL</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX36">CHAR</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX110">INSTRUMENT</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX58">md_device</A>, <A HREF="mikmod.html#IDX104">md_device</A>
<LI><A HREF="mikmod.html#IDX105">md_driver</A>
<LI><A HREF="mikmod.html#IDX59">md_mixfreq</A>, <A HREF="mikmod.html#IDX106">md_mixfreq</A>
<LI><A HREF="mikmod.html#IDX60">md_mode</A>, <A HREF="mikmod.html#IDX107">md_mode</A>
<LI><A HREF="mikmod.html#IDX99">md_musicvolume</A>
<LI><A HREF="mikmod.html#IDX100">md_pansep</A>
<LI><A HREF="mikmod.html#IDX101">md_reverb</A>
<LI><A HREF="mikmod.html#IDX102">md_sndfxvolume</A>
<LI><A HREF="mikmod.html#IDX103">md_volume</A>
<LI><A HREF="mikmod.html#IDX108">MDRIVER</A>
<LI><A HREF="mikmod.html#IDX44">MikMod_critical</A>, <A HREF="mikmod.html#IDX98">MikMod_critical</A>
<LI><A HREF="mikmod.html#IDX9">MikMod_errno</A>, <A HREF="mikmod.html#IDX45">MikMod_errno</A>, <A HREF="mikmod.html#IDX97">MikMod_errno</A>
<LI><A HREF="mikmod.html#IDX46">MikMod_strerror</A>
<LI><A HREF="mikmod.html#IDX109">MODULE</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX111">SAMPLE</A>
<LI><A HREF="mikmod.html#IDX37">SBYTE</A>
<LI><A HREF="mikmod.html#IDX38">SLONG</A>
<LI><A HREF="mikmod.html#IDX39">SWORD</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="mikmod.html#IDX40">UBYTE</A>
<LI><A HREF="mikmod.html#IDX41">ULONG</A>
<LI><A HREF="mikmod.html#IDX42">UWORD</A>
</DIR>

</P>
<P><HR><P>
This document was generated on 14 Febuary 1999 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
